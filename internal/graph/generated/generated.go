// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
	"gitlab.com/rubin-dev/api/internal/graph/model"
	"gitlab.com/rubin-dev/api/pkg/elastic"
	"gitlab.com/rubin-dev/api/pkg/models"
	"gitlab.com/rubin-dev/api/pkg/neoutils"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	BillingKey() BillingKeyResolver
	BillingPacket() BillingPacketResolver
	BillingRequest() BillingRequestResolver
	Mutation() MutationResolver
	Node() NodeResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
	Auth        func(ctx context.Context, obj interface{}, next graphql.Resolver, permissions []string) (res interface{}, err error)
	AuthRefresh func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Billing struct {
		HistoryRequests func(childComplexity int) int
		Requests        func(childComplexity int) int
	}

	BillingAddPacketResponse struct {
		Billing func(childComplexity int) int
		Errors  func(childComplexity int) int
	}

	BillingHistoryListResponse struct {
		Edge   func(childComplexity int) int
		Errors func(childComplexity int) int
		Total  func(childComplexity int) int
	}

	BillingKey struct {
		BillingID func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Key       func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	BillingKeyResponse struct {
		Edge   func(childComplexity int) int
		Errors func(childComplexity int) int
		Total  func(childComplexity int) int
	}

	BillingPacket struct {
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Requests  func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	BillingRequest struct {
		Category  func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Network   func(childComplexity int) int
		Query     func(childComplexity int) int
		Risk      func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	Category struct {
		DescriptionEn func(childComplexity int) int
		DescriptionRu func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Risk          func(childComplexity int) int
	}

	CategoryCreateResponse struct {
		Category func(childComplexity int) int
		Errors   func(childComplexity int) int
	}

	CategoryListResponse struct {
		Edge   func(childComplexity int) int
		Errors func(childComplexity int) int
		Total  func(childComplexity int) int
	}

	CategoryRemoveResponse struct {
		Errors func(childComplexity int) int
	}

	CategoryUpdateResponse struct {
		Category func(childComplexity int) int
		Errors   func(childComplexity int) int
	}

	ChangePasswordResponse struct {
		Errors func(childComplexity int) int
		Jwt    func(childComplexity int) int
	}

	Entity struct {
		Address  func(childComplexity int) int
		Category func(childComplexity int) int
		Chain    func(childComplexity int) int
		Contact  func(childComplexity int) int
		Data     func(childComplexity int) int
		Date     func(childComplexity int) int
	}

	Jwt struct {
		AccessToken  func(childComplexity int) int
		ID           func(childComplexity int) int
		Permissions  func(childComplexity int) int
		RefreshToken func(childComplexity int) int
	}

	LoginResponse struct {
		Errors func(childComplexity int) int
		Jwt    func(childComplexity int) int
	}

	Mutation struct {
		AccessRequest       func(childComplexity int) int
		BillingAddPacket    func(childComplexity int, userID int64, requests int) int
		BillingKeyCreate    func(childComplexity int) int
		BillingKeyRemove    func(childComplexity int, id int64) int
		CategoryCreate      func(childComplexity int, input model.CategoryCreateInput) int
		CategoryRemoveByID  func(childComplexity int, id int64) int
		CategoryUpdate      func(childComplexity int, id int64, input model.CategoryUpdateInput) int
		ChangePassword      func(childComplexity int, input model.ChangePasswordInput) int
		Health              func(childComplexity int) int
		Login               func(childComplexity int, input model.LoginInput) int
		RefreshToken        func(childComplexity int, input model.RefreshTokenInput) int
		Registration        func(childComplexity int, input model.RegistrationInput) int
		RegistrationConfirm func(childComplexity int, input model.RegistrationConfirmInput) int
		Restore             func(childComplexity int, input model.RestoreInput) int
		RestoreCheck        func(childComplexity int, input model.RestoreCheckInput) int
		RestoreConfirm      func(childComplexity int, input model.RestoreConfirmInput) int
	}

	Node struct {
		ID     func(childComplexity int) int
		Labels func(childComplexity int) int
		Props  func(childComplexity int) int
	}

	NodeCountResponse struct {
		Errors func(childComplexity int) int
		Has    func(childComplexity int) int
	}

	NodeEntityResponse struct {
		Errors func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	NodeListResponse struct {
		Edge   func(childComplexity int) int
		Errors func(childComplexity int) int
		Total  func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor   func(childComplexity int) int
		HasNextPage func(childComplexity int) int
		StartCursor func(childComplexity int) int
	}

	Query struct {
		BillingHistoryList                    func(childComplexity int, page int, pageSize int) int
		BillingKeyList                        func(childComplexity int, page int, pageSize int) int
		BtcExistsAddressByHashCount           func(childComplexity int, address string) int
		BtcExistsTransactionByHashCount       func(childComplexity int, address string) int
		BtcFindAddressByHash                  func(childComplexity int, address string) int
		BtcFindAllInputAndOutputByTransaction func(childComplexity int, txid string, page int, pageSize int) int
		BtcFindBlockByHash                    func(childComplexity int, hash string) int
		BtcFindBlockByNumber                  func(childComplexity int, height int) int
		BtcFindBlockByTransaction             func(childComplexity int, txid string) int
		BtcFindContactByAddress               func(childComplexity int, address string) int
		BtcFindIncomingTransactions           func(childComplexity int, txid string, page int, pageSize int) int
		BtcFindMentionsForAddress             func(childComplexity int, address string, page int, pageSize int) int
		BtcFindOutcomingTransactions          func(childComplexity int, txid string, page int, pageSize int) int
		BtcFindRiskScore                      func(childComplexity int, address string) int
		BtcFindTransactionByHash              func(childComplexity int, address string) int
		BtcFindTransactionsByAddress          func(childComplexity int, address string, page int, pageSize int) int
		BtcFindTransactionsInBlock            func(childComplexity int, height int, page int, pageSize int) int
		BtcFindTransactionsInBlockByHash      func(childComplexity int, hash string, page int, pageSize int) int
		BtcFindWalletAddresses                func(childComplexity int, wid string, page int, pageSize int) int
		BtcFindWalletByWid                    func(childComplexity int, wid string) int
		BtcFindWalletForAddress               func(childComplexity int, address string) int
		CategoryFindByID                      func(childComplexity int, id int64) int
		CategoryList                          func(childComplexity int) int
		EthFindAddressByHash                  func(childComplexity int, address string) int
		EthFindAllInputAndOutputTransactions  func(childComplexity int, hash string, page int, pageSize int) int
		EthFindBlockByHash                    func(childComplexity int, hash string) int
		EthFindBlockByHeight                  func(childComplexity int, height string) int
		EthFindBlockByTransaction             func(childComplexity int, hash string) int
		EthFindContactByAddress               func(childComplexity int, address string) int
		EthFindIncomingTransactionAddress     func(childComplexity int, hash string) int
		EthFindMentionsByAddress              func(childComplexity int, address string, page int, pageSize int) int
		EthFindOutcomingTransactionAddress    func(childComplexity int, hash string) int
		EthFindRiskScoreByAddress             func(childComplexity int, address string) int
		EthFindTransactionByHash              func(childComplexity int, hash string) int
		EthFindTransactionsByAddress          func(childComplexity int, hash string, page int, pageSize int) int
		EthFindTransactionsInBlock            func(childComplexity int, height string, page int, pageSize int) int
		Health                                func(childComplexity int) int
		Me                                    func(childComplexity int) int
		Search                                func(childComplexity int, query string, page int, limit int) int
		SearchCount                           func(childComplexity int, query string) int
		User                                  func(childComplexity int, id int64) int
		UserList                              func(childComplexity int, page int, pageSize int) int
	}

	RefreshTokenResponse struct {
		Errors func(childComplexity int) int
		Result func(childComplexity int) int
	}

	RegistrationConfirmResponse struct {
		Errors func(childComplexity int) int
		Jwt    func(childComplexity int) int
	}

	RegistrationResponse struct {
		Errors func(childComplexity int) int
		State  func(childComplexity int) int
	}

	RestoreConfirmResponse struct {
		Errors func(childComplexity int) int
		Jwt    func(childComplexity int) int
	}

	RestoreResponse struct {
		Errors func(childComplexity int) int
		State  func(childComplexity int) int
	}

	SearchCountResponse struct {
		Count  func(childComplexity int) int
		Errors func(childComplexity int) int
	}

	SearchResponse struct {
		Edge   func(childComplexity int) int
		Errors func(childComplexity int) int
		Total  func(childComplexity int) int
	}

	Subscription struct {
		Health func(childComplexity int) int
	}

	User struct {
		Billing     func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Email       func(childComplexity int) int
		ID          func(childComplexity int) int
		IsActive    func(childComplexity int) int
		Name        func(childComplexity int) int
		Permissions func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	UserListResponse struct {
		Edge   func(childComplexity int) int
		Errors func(childComplexity int) int
		Total  func(childComplexity int) int
	}
}

type BillingKeyResolver interface {
	CreatedAt(ctx context.Context, obj *models.BillingKey) (string, error)
}
type BillingPacketResolver interface {
	CreatedAt(ctx context.Context, obj *models.BillingPacket) (string, error)
}
type BillingRequestResolver interface {
	CreatedAt(ctx context.Context, obj *models.BillingRequest) (string, error)
}
type MutationResolver interface {
	Health(ctx context.Context) (bool, error)
	AccessRequest(ctx context.Context) (bool, error)
	Login(ctx context.Context, input model.LoginInput) (*model.LoginResponse, error)
	RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.RefreshTokenResponse, error)
	Restore(ctx context.Context, input model.RestoreInput) (*model.RestoreResponse, error)
	RestoreCheck(ctx context.Context, input model.RestoreCheckInput) (*model.RestoreResponse, error)
	RestoreConfirm(ctx context.Context, input model.RestoreConfirmInput) (*model.RestoreConfirmResponse, error)
	Registration(ctx context.Context, input model.RegistrationInput) (*model.RegistrationResponse, error)
	RegistrationConfirm(ctx context.Context, input model.RegistrationConfirmInput) (*model.RegistrationConfirmResponse, error)
	ChangePassword(ctx context.Context, input model.ChangePasswordInput) (*model.ChangePasswordResponse, error)
	BillingAddPacket(ctx context.Context, userID int64, requests int) (*model.BillingAddPacketResponse, error)
	BillingKeyCreate(ctx context.Context) (*models.BillingKey, error)
	BillingKeyRemove(ctx context.Context, id int64) (bool, error)
	CategoryCreate(ctx context.Context, input model.CategoryCreateInput) (*model.CategoryCreateResponse, error)
	CategoryUpdate(ctx context.Context, id int64, input model.CategoryUpdateInput) (*model.CategoryUpdateResponse, error)
	CategoryRemoveByID(ctx context.Context, id int64) (*model.CategoryRemoveResponse, error)
}
type NodeResolver interface {
	Props(ctx context.Context, obj *neoutils.Node) (interface{}, error)
}
type QueryResolver interface {
	Health(ctx context.Context) (bool, error)
	Me(ctx context.Context) (*models.User, error)
	BillingHistoryList(ctx context.Context, page int, pageSize int) (*model.BillingHistoryListResponse, error)
	BillingKeyList(ctx context.Context, page int, pageSize int) (*model.BillingKeyResponse, error)
	BtcExistsAddressByHashCount(ctx context.Context, address string) (*model.NodeCountResponse, error)
	BtcExistsTransactionByHashCount(ctx context.Context, address string) (*model.NodeCountResponse, error)
	BtcFindContactByAddress(ctx context.Context, address string) (*model.NodeEntityResponse, error)
	BtcFindTransactionByHash(ctx context.Context, address string) (*model.NodeEntityResponse, error)
	BtcFindAddressByHash(ctx context.Context, address string) (*model.NodeEntityResponse, error)
	BtcFindWalletForAddress(ctx context.Context, address string) (*model.NodeEntityResponse, error)
	BtcFindRiskScore(ctx context.Context, address string) (*model.NodeEntityResponse, error)
	BtcFindBlockByNumber(ctx context.Context, height int) (*model.NodeEntityResponse, error)
	BtcFindBlockByHash(ctx context.Context, hash string) (*model.NodeEntityResponse, error)
	BtcFindBlockByTransaction(ctx context.Context, txid string) (*model.NodeEntityResponse, error)
	BtcFindTransactionsByAddress(ctx context.Context, address string, page int, pageSize int) (*model.NodeListResponse, error)
	BtcFindMentionsForAddress(ctx context.Context, address string, page int, pageSize int) (*model.NodeListResponse, error)
	BtcFindIncomingTransactions(ctx context.Context, txid string, page int, pageSize int) (*model.NodeListResponse, error)
	BtcFindOutcomingTransactions(ctx context.Context, txid string, page int, pageSize int) (*model.NodeListResponse, error)
	BtcFindTransactionsInBlock(ctx context.Context, height int, page int, pageSize int) (*model.NodeListResponse, error)
	BtcFindAllInputAndOutputByTransaction(ctx context.Context, txid string, page int, pageSize int) (*model.NodeListResponse, error)
	BtcFindTransactionsInBlockByHash(ctx context.Context, hash string, page int, pageSize int) (*model.NodeListResponse, error)
	BtcFindWalletByWid(ctx context.Context, wid string) (*model.NodeEntityResponse, error)
	BtcFindWalletAddresses(ctx context.Context, wid string, page int, pageSize int) (*model.NodeListResponse, error)
	CategoryList(ctx context.Context) (*model.CategoryListResponse, error)
	CategoryFindByID(ctx context.Context, id int64) (*models.Category, error)
	EthFindAddressByHash(ctx context.Context, address string) (*model.NodeEntityResponse, error)
	EthFindTransactionsByAddress(ctx context.Context, hash string, page int, pageSize int) (*model.NodeListResponse, error)
	EthFindTransactionByHash(ctx context.Context, hash string) (*model.NodeEntityResponse, error)
	EthFindIncomingTransactionAddress(ctx context.Context, hash string) (*model.NodeEntityResponse, error)
	EthFindOutcomingTransactionAddress(ctx context.Context, hash string) (*model.NodeEntityResponse, error)
	EthFindBlockByTransaction(ctx context.Context, hash string) (*model.NodeEntityResponse, error)
	EthFindBlockByHeight(ctx context.Context, height string) (*model.NodeEntityResponse, error)
	EthFindTransactionsInBlock(ctx context.Context, height string, page int, pageSize int) (*model.NodeListResponse, error)
	EthFindAllInputAndOutputTransactions(ctx context.Context, hash string, page int, pageSize int) (*model.NodeListResponse, error)
	EthFindBlockByHash(ctx context.Context, hash string) (*model.NodeEntityResponse, error)
	EthFindMentionsByAddress(ctx context.Context, address string, page int, pageSize int) (*model.NodeListResponse, error)
	EthFindContactByAddress(ctx context.Context, address string) (*model.NodeEntityResponse, error)
	EthFindRiskScoreByAddress(ctx context.Context, address string) (*model.NodeEntityResponse, error)
	Search(ctx context.Context, query string, page int, limit int) (*model.SearchResponse, error)
	SearchCount(ctx context.Context, query string) (*model.SearchCountResponse, error)
	User(ctx context.Context, id int64) (*models.User, error)
	UserList(ctx context.Context, page int, pageSize int) (*model.UserListResponse, error)
}
type SubscriptionResolver interface {
	Health(ctx context.Context) (<-chan bool, error)
}
type UserResolver interface {
	CreatedAt(ctx context.Context, obj *models.User) (string, error)
	UpdatedAt(ctx context.Context, obj *models.User) (string, error)
	Billing(ctx context.Context, obj *models.User) (*model.Billing, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Billing.historyRequests":
		if e.complexity.Billing.HistoryRequests == nil {
			break
		}

		return e.complexity.Billing.HistoryRequests(childComplexity), true

	case "Billing.requests":
		if e.complexity.Billing.Requests == nil {
			break
		}

		return e.complexity.Billing.Requests(childComplexity), true

	case "BillingAddPacketResponse.billing":
		if e.complexity.BillingAddPacketResponse.Billing == nil {
			break
		}

		return e.complexity.BillingAddPacketResponse.Billing(childComplexity), true

	case "BillingAddPacketResponse.errors":
		if e.complexity.BillingAddPacketResponse.Errors == nil {
			break
		}

		return e.complexity.BillingAddPacketResponse.Errors(childComplexity), true

	case "BillingHistoryListResponse.edge":
		if e.complexity.BillingHistoryListResponse.Edge == nil {
			break
		}

		return e.complexity.BillingHistoryListResponse.Edge(childComplexity), true

	case "BillingHistoryListResponse.errors":
		if e.complexity.BillingHistoryListResponse.Errors == nil {
			break
		}

		return e.complexity.BillingHistoryListResponse.Errors(childComplexity), true

	case "BillingHistoryListResponse.total":
		if e.complexity.BillingHistoryListResponse.Total == nil {
			break
		}

		return e.complexity.BillingHistoryListResponse.Total(childComplexity), true

	case "BillingKey.billingId":
		if e.complexity.BillingKey.BillingID == nil {
			break
		}

		return e.complexity.BillingKey.BillingID(childComplexity), true

	case "BillingKey.createdAt":
		if e.complexity.BillingKey.CreatedAt == nil {
			break
		}

		return e.complexity.BillingKey.CreatedAt(childComplexity), true

	case "BillingKey.id":
		if e.complexity.BillingKey.ID == nil {
			break
		}

		return e.complexity.BillingKey.ID(childComplexity), true

	case "BillingKey.key":
		if e.complexity.BillingKey.Key == nil {
			break
		}

		return e.complexity.BillingKey.Key(childComplexity), true

	case "BillingKey.userId":
		if e.complexity.BillingKey.UserID == nil {
			break
		}

		return e.complexity.BillingKey.UserID(childComplexity), true

	case "BillingKeyResponse.edge":
		if e.complexity.BillingKeyResponse.Edge == nil {
			break
		}

		return e.complexity.BillingKeyResponse.Edge(childComplexity), true

	case "BillingKeyResponse.errors":
		if e.complexity.BillingKeyResponse.Errors == nil {
			break
		}

		return e.complexity.BillingKeyResponse.Errors(childComplexity), true

	case "BillingKeyResponse.total":
		if e.complexity.BillingKeyResponse.Total == nil {
			break
		}

		return e.complexity.BillingKeyResponse.Total(childComplexity), true

	case "BillingPacket.createdAt":
		if e.complexity.BillingPacket.CreatedAt == nil {
			break
		}

		return e.complexity.BillingPacket.CreatedAt(childComplexity), true

	case "BillingPacket.id":
		if e.complexity.BillingPacket.ID == nil {
			break
		}

		return e.complexity.BillingPacket.ID(childComplexity), true

	case "BillingPacket.requests":
		if e.complexity.BillingPacket.Requests == nil {
			break
		}

		return e.complexity.BillingPacket.Requests(childComplexity), true

	case "BillingPacket.userId":
		if e.complexity.BillingPacket.UserID == nil {
			break
		}

		return e.complexity.BillingPacket.UserID(childComplexity), true

	case "BillingRequest.category":
		if e.complexity.BillingRequest.Category == nil {
			break
		}

		return e.complexity.BillingRequest.Category(childComplexity), true

	case "BillingRequest.createdAt":
		if e.complexity.BillingRequest.CreatedAt == nil {
			break
		}

		return e.complexity.BillingRequest.CreatedAt(childComplexity), true

	case "BillingRequest.id":
		if e.complexity.BillingRequest.ID == nil {
			break
		}

		return e.complexity.BillingRequest.ID(childComplexity), true

	case "BillingRequest.network":
		if e.complexity.BillingRequest.Network == nil {
			break
		}

		return e.complexity.BillingRequest.Network(childComplexity), true

	case "BillingRequest.query":
		if e.complexity.BillingRequest.Query == nil {
			break
		}

		return e.complexity.BillingRequest.Query(childComplexity), true

	case "BillingRequest.risk":
		if e.complexity.BillingRequest.Risk == nil {
			break
		}

		return e.complexity.BillingRequest.Risk(childComplexity), true

	case "BillingRequest.userId":
		if e.complexity.BillingRequest.UserID == nil {
			break
		}

		return e.complexity.BillingRequest.UserID(childComplexity), true

	case "Category.descriptionEn":
		if e.complexity.Category.DescriptionEn == nil {
			break
		}

		return e.complexity.Category.DescriptionEn(childComplexity), true

	case "Category.descriptionRu":
		if e.complexity.Category.DescriptionRu == nil {
			break
		}

		return e.complexity.Category.DescriptionRu(childComplexity), true

	case "Category.id":
		if e.complexity.Category.ID == nil {
			break
		}

		return e.complexity.Category.ID(childComplexity), true

	case "Category.name":
		if e.complexity.Category.Name == nil {
			break
		}

		return e.complexity.Category.Name(childComplexity), true

	case "Category.risk":
		if e.complexity.Category.Risk == nil {
			break
		}

		return e.complexity.Category.Risk(childComplexity), true

	case "CategoryCreateResponse.category":
		if e.complexity.CategoryCreateResponse.Category == nil {
			break
		}

		return e.complexity.CategoryCreateResponse.Category(childComplexity), true

	case "CategoryCreateResponse.errors":
		if e.complexity.CategoryCreateResponse.Errors == nil {
			break
		}

		return e.complexity.CategoryCreateResponse.Errors(childComplexity), true

	case "CategoryListResponse.edge":
		if e.complexity.CategoryListResponse.Edge == nil {
			break
		}

		return e.complexity.CategoryListResponse.Edge(childComplexity), true

	case "CategoryListResponse.errors":
		if e.complexity.CategoryListResponse.Errors == nil {
			break
		}

		return e.complexity.CategoryListResponse.Errors(childComplexity), true

	case "CategoryListResponse.total":
		if e.complexity.CategoryListResponse.Total == nil {
			break
		}

		return e.complexity.CategoryListResponse.Total(childComplexity), true

	case "CategoryRemoveResponse.errors":
		if e.complexity.CategoryRemoveResponse.Errors == nil {
			break
		}

		return e.complexity.CategoryRemoveResponse.Errors(childComplexity), true

	case "CategoryUpdateResponse.category":
		if e.complexity.CategoryUpdateResponse.Category == nil {
			break
		}

		return e.complexity.CategoryUpdateResponse.Category(childComplexity), true

	case "CategoryUpdateResponse.errors":
		if e.complexity.CategoryUpdateResponse.Errors == nil {
			break
		}

		return e.complexity.CategoryUpdateResponse.Errors(childComplexity), true

	case "ChangePasswordResponse.errors":
		if e.complexity.ChangePasswordResponse.Errors == nil {
			break
		}

		return e.complexity.ChangePasswordResponse.Errors(childComplexity), true

	case "ChangePasswordResponse.jwt":
		if e.complexity.ChangePasswordResponse.Jwt == nil {
			break
		}

		return e.complexity.ChangePasswordResponse.Jwt(childComplexity), true

	case "Entity.address":
		if e.complexity.Entity.Address == nil {
			break
		}

		return e.complexity.Entity.Address(childComplexity), true

	case "Entity.category":
		if e.complexity.Entity.Category == nil {
			break
		}

		return e.complexity.Entity.Category(childComplexity), true

	case "Entity.chain":
		if e.complexity.Entity.Chain == nil {
			break
		}

		return e.complexity.Entity.Chain(childComplexity), true

	case "Entity.contact":
		if e.complexity.Entity.Contact == nil {
			break
		}

		return e.complexity.Entity.Contact(childComplexity), true

	case "Entity.data":
		if e.complexity.Entity.Data == nil {
			break
		}

		return e.complexity.Entity.Data(childComplexity), true

	case "Entity.date":
		if e.complexity.Entity.Date == nil {
			break
		}

		return e.complexity.Entity.Date(childComplexity), true

	case "Jwt.accessToken":
		if e.complexity.Jwt.AccessToken == nil {
			break
		}

		return e.complexity.Jwt.AccessToken(childComplexity), true

	case "Jwt.id":
		if e.complexity.Jwt.ID == nil {
			break
		}

		return e.complexity.Jwt.ID(childComplexity), true

	case "Jwt.permissions":
		if e.complexity.Jwt.Permissions == nil {
			break
		}

		return e.complexity.Jwt.Permissions(childComplexity), true

	case "Jwt.refreshToken":
		if e.complexity.Jwt.RefreshToken == nil {
			break
		}

		return e.complexity.Jwt.RefreshToken(childComplexity), true

	case "LoginResponse.errors":
		if e.complexity.LoginResponse.Errors == nil {
			break
		}

		return e.complexity.LoginResponse.Errors(childComplexity), true

	case "LoginResponse.jwt":
		if e.complexity.LoginResponse.Jwt == nil {
			break
		}

		return e.complexity.LoginResponse.Jwt(childComplexity), true

	case "Mutation.accessRequest":
		if e.complexity.Mutation.AccessRequest == nil {
			break
		}

		return e.complexity.Mutation.AccessRequest(childComplexity), true

	case "Mutation.billingAddPacket":
		if e.complexity.Mutation.BillingAddPacket == nil {
			break
		}

		args, err := ec.field_Mutation_billingAddPacket_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BillingAddPacket(childComplexity, args["userId"].(int64), args["requests"].(int)), true

	case "Mutation.billingKeyCreate":
		if e.complexity.Mutation.BillingKeyCreate == nil {
			break
		}

		return e.complexity.Mutation.BillingKeyCreate(childComplexity), true

	case "Mutation.billingKeyRemove":
		if e.complexity.Mutation.BillingKeyRemove == nil {
			break
		}

		args, err := ec.field_Mutation_billingKeyRemove_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BillingKeyRemove(childComplexity, args["id"].(int64)), true

	case "Mutation.categoryCreate":
		if e.complexity.Mutation.CategoryCreate == nil {
			break
		}

		args, err := ec.field_Mutation_categoryCreate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CategoryCreate(childComplexity, args["input"].(model.CategoryCreateInput)), true

	case "Mutation.categoryRemoveById":
		if e.complexity.Mutation.CategoryRemoveByID == nil {
			break
		}

		args, err := ec.field_Mutation_categoryRemoveById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CategoryRemoveByID(childComplexity, args["id"].(int64)), true

	case "Mutation.categoryUpdate":
		if e.complexity.Mutation.CategoryUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_categoryUpdate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CategoryUpdate(childComplexity, args["id"].(int64), args["input"].(model.CategoryUpdateInput)), true

	case "Mutation.changePassword":
		if e.complexity.Mutation.ChangePassword == nil {
			break
		}

		args, err := ec.field_Mutation_changePassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ChangePassword(childComplexity, args["input"].(model.ChangePasswordInput)), true

	case "Mutation.health":
		if e.complexity.Mutation.Health == nil {
			break
		}

		return e.complexity.Mutation.Health(childComplexity), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.LoginInput)), true

	case "Mutation.refreshToken":
		if e.complexity.Mutation.RefreshToken == nil {
			break
		}

		args, err := ec.field_Mutation_refreshToken_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RefreshToken(childComplexity, args["input"].(model.RefreshTokenInput)), true

	case "Mutation.registration":
		if e.complexity.Mutation.Registration == nil {
			break
		}

		args, err := ec.field_Mutation_registration_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Registration(childComplexity, args["input"].(model.RegistrationInput)), true

	case "Mutation.registrationConfirm":
		if e.complexity.Mutation.RegistrationConfirm == nil {
			break
		}

		args, err := ec.field_Mutation_registrationConfirm_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegistrationConfirm(childComplexity, args["input"].(model.RegistrationConfirmInput)), true

	case "Mutation.restore":
		if e.complexity.Mutation.Restore == nil {
			break
		}

		args, err := ec.field_Mutation_restore_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Restore(childComplexity, args["input"].(model.RestoreInput)), true

	case "Mutation.restoreCheck":
		if e.complexity.Mutation.RestoreCheck == nil {
			break
		}

		args, err := ec.field_Mutation_restoreCheck_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestoreCheck(childComplexity, args["input"].(model.RestoreCheckInput)), true

	case "Mutation.restoreConfirm":
		if e.complexity.Mutation.RestoreConfirm == nil {
			break
		}

		args, err := ec.field_Mutation_restoreConfirm_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestoreConfirm(childComplexity, args["input"].(model.RestoreConfirmInput)), true

	case "Node.id":
		if e.complexity.Node.ID == nil {
			break
		}

		return e.complexity.Node.ID(childComplexity), true

	case "Node.labels":
		if e.complexity.Node.Labels == nil {
			break
		}

		return e.complexity.Node.Labels(childComplexity), true

	case "Node.props":
		if e.complexity.Node.Props == nil {
			break
		}

		return e.complexity.Node.Props(childComplexity), true

	case "NodeCountResponse.errors":
		if e.complexity.NodeCountResponse.Errors == nil {
			break
		}

		return e.complexity.NodeCountResponse.Errors(childComplexity), true

	case "NodeCountResponse.has":
		if e.complexity.NodeCountResponse.Has == nil {
			break
		}

		return e.complexity.NodeCountResponse.Has(childComplexity), true

	case "NodeEntityResponse.errors":
		if e.complexity.NodeEntityResponse.Errors == nil {
			break
		}

		return e.complexity.NodeEntityResponse.Errors(childComplexity), true

	case "NodeEntityResponse.node":
		if e.complexity.NodeEntityResponse.Node == nil {
			break
		}

		return e.complexity.NodeEntityResponse.Node(childComplexity), true

	case "NodeListResponse.edge":
		if e.complexity.NodeListResponse.Edge == nil {
			break
		}

		return e.complexity.NodeListResponse.Edge(childComplexity), true

	case "NodeListResponse.errors":
		if e.complexity.NodeListResponse.Errors == nil {
			break
		}

		return e.complexity.NodeListResponse.Errors(childComplexity), true

	case "NodeListResponse.total":
		if e.complexity.NodeListResponse.Total == nil {
			break
		}

		return e.complexity.NodeListResponse.Total(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.billingHistoryList":
		if e.complexity.Query.BillingHistoryList == nil {
			break
		}

		args, err := ec.field_Query_billingHistoryList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BillingHistoryList(childComplexity, args["page"].(int), args["pageSize"].(int)), true

	case "Query.billingKeyList":
		if e.complexity.Query.BillingKeyList == nil {
			break
		}

		args, err := ec.field_Query_billingKeyList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BillingKeyList(childComplexity, args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcExistsAddressByHashCount":
		if e.complexity.Query.BtcExistsAddressByHashCount == nil {
			break
		}

		args, err := ec.field_Query_btcExistsAddressByHashCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcExistsAddressByHashCount(childComplexity, args["address"].(string)), true

	case "Query.btcExistsTransactionByHashCount":
		if e.complexity.Query.BtcExistsTransactionByHashCount == nil {
			break
		}

		args, err := ec.field_Query_btcExistsTransactionByHashCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcExistsTransactionByHashCount(childComplexity, args["address"].(string)), true

	case "Query.btcFindAddressByHash":
		if e.complexity.Query.BtcFindAddressByHash == nil {
			break
		}

		args, err := ec.field_Query_btcFindAddressByHash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindAddressByHash(childComplexity, args["address"].(string)), true

	case "Query.btcFindAllInputAndOutputByTransaction":
		if e.complexity.Query.BtcFindAllInputAndOutputByTransaction == nil {
			break
		}

		args, err := ec.field_Query_btcFindAllInputAndOutputByTransaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindAllInputAndOutputByTransaction(childComplexity, args["txid"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcFindBlockByHash":
		if e.complexity.Query.BtcFindBlockByHash == nil {
			break
		}

		args, err := ec.field_Query_btcFindBlockByHash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindBlockByHash(childComplexity, args["hash"].(string)), true

	case "Query.btcFindBlockByNumber":
		if e.complexity.Query.BtcFindBlockByNumber == nil {
			break
		}

		args, err := ec.field_Query_btcFindBlockByNumber_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindBlockByNumber(childComplexity, args["height"].(int)), true

	case "Query.btcFindBlockByTransaction":
		if e.complexity.Query.BtcFindBlockByTransaction == nil {
			break
		}

		args, err := ec.field_Query_btcFindBlockByTransaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindBlockByTransaction(childComplexity, args["txid"].(string)), true

	case "Query.btcFindContactByAddress":
		if e.complexity.Query.BtcFindContactByAddress == nil {
			break
		}

		args, err := ec.field_Query_btcFindContactByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindContactByAddress(childComplexity, args["address"].(string)), true

	case "Query.btcFindIncomingTransactions":
		if e.complexity.Query.BtcFindIncomingTransactions == nil {
			break
		}

		args, err := ec.field_Query_btcFindIncomingTransactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindIncomingTransactions(childComplexity, args["txid"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcFindMentionsForAddress":
		if e.complexity.Query.BtcFindMentionsForAddress == nil {
			break
		}

		args, err := ec.field_Query_btcFindMentionsForAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindMentionsForAddress(childComplexity, args["address"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcFindOutcomingTransactions":
		if e.complexity.Query.BtcFindOutcomingTransactions == nil {
			break
		}

		args, err := ec.field_Query_btcFindOutcomingTransactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindOutcomingTransactions(childComplexity, args["txid"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcFindRiskScore":
		if e.complexity.Query.BtcFindRiskScore == nil {
			break
		}

		args, err := ec.field_Query_btcFindRiskScore_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindRiskScore(childComplexity, args["address"].(string)), true

	case "Query.btcFindTransactionByHash":
		if e.complexity.Query.BtcFindTransactionByHash == nil {
			break
		}

		args, err := ec.field_Query_btcFindTransactionByHash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindTransactionByHash(childComplexity, args["address"].(string)), true

	case "Query.btcFindTransactionsByAddress":
		if e.complexity.Query.BtcFindTransactionsByAddress == nil {
			break
		}

		args, err := ec.field_Query_btcFindTransactionsByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindTransactionsByAddress(childComplexity, args["address"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcFindTransactionsInBlock":
		if e.complexity.Query.BtcFindTransactionsInBlock == nil {
			break
		}

		args, err := ec.field_Query_btcFindTransactionsInBlock_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindTransactionsInBlock(childComplexity, args["height"].(int), args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcFindTransactionsInBlockByHash":
		if e.complexity.Query.BtcFindTransactionsInBlockByHash == nil {
			break
		}

		args, err := ec.field_Query_btcFindTransactionsInBlockByHash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindTransactionsInBlockByHash(childComplexity, args["hash"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcFindWalletAddresses":
		if e.complexity.Query.BtcFindWalletAddresses == nil {
			break
		}

		args, err := ec.field_Query_btcFindWalletAddresses_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindWalletAddresses(childComplexity, args["wid"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.btcFindWalletByWid":
		if e.complexity.Query.BtcFindWalletByWid == nil {
			break
		}

		args, err := ec.field_Query_btcFindWalletByWid_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindWalletByWid(childComplexity, args["wid"].(string)), true

	case "Query.btcFindWalletForAddress":
		if e.complexity.Query.BtcFindWalletForAddress == nil {
			break
		}

		args, err := ec.field_Query_btcFindWalletForAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BtcFindWalletForAddress(childComplexity, args["address"].(string)), true

	case "Query.categoryFindById":
		if e.complexity.Query.CategoryFindByID == nil {
			break
		}

		args, err := ec.field_Query_categoryFindById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CategoryFindByID(childComplexity, args["id"].(int64)), true

	case "Query.categoryList":
		if e.complexity.Query.CategoryList == nil {
			break
		}

		return e.complexity.Query.CategoryList(childComplexity), true

	case "Query.ethFindAddressByHash":
		if e.complexity.Query.EthFindAddressByHash == nil {
			break
		}

		args, err := ec.field_Query_ethFindAddressByHash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindAddressByHash(childComplexity, args["address"].(string)), true

	case "Query.ethFindAllInputAndOutputTransactions":
		if e.complexity.Query.EthFindAllInputAndOutputTransactions == nil {
			break
		}

		args, err := ec.field_Query_ethFindAllInputAndOutputTransactions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindAllInputAndOutputTransactions(childComplexity, args["hash"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.ethFindBlockByHash":
		if e.complexity.Query.EthFindBlockByHash == nil {
			break
		}

		args, err := ec.field_Query_ethFindBlockByHash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindBlockByHash(childComplexity, args["hash"].(string)), true

	case "Query.ethFindBlockByHeight":
		if e.complexity.Query.EthFindBlockByHeight == nil {
			break
		}

		args, err := ec.field_Query_ethFindBlockByHeight_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindBlockByHeight(childComplexity, args["height"].(string)), true

	case "Query.ethFindBlockByTransaction":
		if e.complexity.Query.EthFindBlockByTransaction == nil {
			break
		}

		args, err := ec.field_Query_ethFindBlockByTransaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindBlockByTransaction(childComplexity, args["hash"].(string)), true

	case "Query.ethFindContactByAddress":
		if e.complexity.Query.EthFindContactByAddress == nil {
			break
		}

		args, err := ec.field_Query_ethFindContactByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindContactByAddress(childComplexity, args["address"].(string)), true

	case "Query.ethFindIncomingTransactionAddress":
		if e.complexity.Query.EthFindIncomingTransactionAddress == nil {
			break
		}

		args, err := ec.field_Query_ethFindIncomingTransactionAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindIncomingTransactionAddress(childComplexity, args["hash"].(string)), true

	case "Query.ethFindMentionsByAddress":
		if e.complexity.Query.EthFindMentionsByAddress == nil {
			break
		}

		args, err := ec.field_Query_ethFindMentionsByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindMentionsByAddress(childComplexity, args["address"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.ethFindOutcomingTransactionAddress":
		if e.complexity.Query.EthFindOutcomingTransactionAddress == nil {
			break
		}

		args, err := ec.field_Query_ethFindOutcomingTransactionAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindOutcomingTransactionAddress(childComplexity, args["hash"].(string)), true

	case "Query.ethFindRiskScoreByAddress":
		if e.complexity.Query.EthFindRiskScoreByAddress == nil {
			break
		}

		args, err := ec.field_Query_ethFindRiskScoreByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindRiskScoreByAddress(childComplexity, args["address"].(string)), true

	case "Query.ethFindTransactionByHash":
		if e.complexity.Query.EthFindTransactionByHash == nil {
			break
		}

		args, err := ec.field_Query_ethFindTransactionByHash_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindTransactionByHash(childComplexity, args["hash"].(string)), true

	case "Query.ethFindTransactionsByAddress":
		if e.complexity.Query.EthFindTransactionsByAddress == nil {
			break
		}

		args, err := ec.field_Query_ethFindTransactionsByAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindTransactionsByAddress(childComplexity, args["hash"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.ethFindTransactionsInBlock":
		if e.complexity.Query.EthFindTransactionsInBlock == nil {
			break
		}

		args, err := ec.field_Query_ethFindTransactionsInBlock_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.EthFindTransactionsInBlock(childComplexity, args["height"].(string), args["page"].(int), args["pageSize"].(int)), true

	case "Query.health":
		if e.complexity.Query.Health == nil {
			break
		}

		return e.complexity.Query.Health(childComplexity), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.search":
		if e.complexity.Query.Search == nil {
			break
		}

		args, err := ec.field_Query_search_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Search(childComplexity, args["query"].(string), args["page"].(int), args["limit"].(int)), true

	case "Query.searchCount":
		if e.complexity.Query.SearchCount == nil {
			break
		}

		args, err := ec.field_Query_searchCount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchCount(childComplexity, args["query"].(string)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["id"].(int64)), true

	case "Query.userList":
		if e.complexity.Query.UserList == nil {
			break
		}

		args, err := ec.field_Query_userList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserList(childComplexity, args["page"].(int), args["pageSize"].(int)), true

	case "RefreshTokenResponse.errors":
		if e.complexity.RefreshTokenResponse.Errors == nil {
			break
		}

		return e.complexity.RefreshTokenResponse.Errors(childComplexity), true

	case "RefreshTokenResponse.result":
		if e.complexity.RefreshTokenResponse.Result == nil {
			break
		}

		return e.complexity.RefreshTokenResponse.Result(childComplexity), true

	case "RegistrationConfirmResponse.errors":
		if e.complexity.RegistrationConfirmResponse.Errors == nil {
			break
		}

		return e.complexity.RegistrationConfirmResponse.Errors(childComplexity), true

	case "RegistrationConfirmResponse.jwt":
		if e.complexity.RegistrationConfirmResponse.Jwt == nil {
			break
		}

		return e.complexity.RegistrationConfirmResponse.Jwt(childComplexity), true

	case "RegistrationResponse.errors":
		if e.complexity.RegistrationResponse.Errors == nil {
			break
		}

		return e.complexity.RegistrationResponse.Errors(childComplexity), true

	case "RegistrationResponse.state":
		if e.complexity.RegistrationResponse.State == nil {
			break
		}

		return e.complexity.RegistrationResponse.State(childComplexity), true

	case "RestoreConfirmResponse.errors":
		if e.complexity.RestoreConfirmResponse.Errors == nil {
			break
		}

		return e.complexity.RestoreConfirmResponse.Errors(childComplexity), true

	case "RestoreConfirmResponse.jwt":
		if e.complexity.RestoreConfirmResponse.Jwt == nil {
			break
		}

		return e.complexity.RestoreConfirmResponse.Jwt(childComplexity), true

	case "RestoreResponse.errors":
		if e.complexity.RestoreResponse.Errors == nil {
			break
		}

		return e.complexity.RestoreResponse.Errors(childComplexity), true

	case "RestoreResponse.state":
		if e.complexity.RestoreResponse.State == nil {
			break
		}

		return e.complexity.RestoreResponse.State(childComplexity), true

	case "SearchCountResponse.count":
		if e.complexity.SearchCountResponse.Count == nil {
			break
		}

		return e.complexity.SearchCountResponse.Count(childComplexity), true

	case "SearchCountResponse.errors":
		if e.complexity.SearchCountResponse.Errors == nil {
			break
		}

		return e.complexity.SearchCountResponse.Errors(childComplexity), true

	case "SearchResponse.edge":
		if e.complexity.SearchResponse.Edge == nil {
			break
		}

		return e.complexity.SearchResponse.Edge(childComplexity), true

	case "SearchResponse.errors":
		if e.complexity.SearchResponse.Errors == nil {
			break
		}

		return e.complexity.SearchResponse.Errors(childComplexity), true

	case "SearchResponse.total":
		if e.complexity.SearchResponse.Total == nil {
			break
		}

		return e.complexity.SearchResponse.Total(childComplexity), true

	case "Subscription.health":
		if e.complexity.Subscription.Health == nil {
			break
		}

		return e.complexity.Subscription.Health(childComplexity), true

	case "User.billing":
		if e.complexity.User.Billing == nil {
			break
		}

		return e.complexity.User.Billing(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.isActive":
		if e.complexity.User.IsActive == nil {
			break
		}

		return e.complexity.User.IsActive(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.permissions":
		if e.complexity.User.Permissions == nil {
			break
		}

		return e.complexity.User.Permissions(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	case "UserListResponse.edge":
		if e.complexity.UserListResponse.Edge == nil {
			break
		}

		return e.complexity.UserListResponse.Edge(childComplexity), true

	case "UserListResponse.errors":
		if e.complexity.UserListResponse.Errors == nil {
			break
		}

		return e.complexity.UserListResponse.Errors(childComplexity), true

	case "UserListResponse.total":
		if e.complexity.UserListResponse.Total == nil {
			break
		}

		return e.complexity.UserListResponse.Total(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCategoryCreateInput,
		ec.unmarshalInputCategoryUpdateInput,
		ec.unmarshalInputChangePasswordInput,
		ec.unmarshalInputLoginInput,
		ec.unmarshalInputRefreshTokenInput,
		ec.unmarshalInputRegistrationConfirmInput,
		ec.unmarshalInputRegistrationInput,
		ec.unmarshalInputRestoreCheckInput,
		ec.unmarshalInputRestoreConfirmInput,
		ec.unmarshalInputRestoreInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, rc.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/accessRequest.graphqls", Input: `extend type Mutation {
    accessRequest: Boolean! @auth
}
`, BuiltIn: false},
	{Name: "../schema/auth.graphqls", Input: `type Jwt {
    id: ID!
    accessToken: String!
    permissions: [String!]!
    refreshToken: String!
}

# Signup
input RegistrationInput {
    name: String!
    email: String!
    password: String!
    passwordConfirm: String!
}

# Signup confirmation
input RegistrationConfirmInput {
    token: String
}

# Sign in by email & password
input LoginInput {
    email: String!
    password: String!
}

# Restore password
input RestoreInput {
    email: String
}

# Restore password check
input RestoreCheckInput {
    token: String
}

# Restore password confirm & change password
input RestoreConfirmInput {
    token: String
    password: String
    passwordConfirm: String
}

# Refresh access & refresh jwt tokens
input RefreshTokenInput {
    token: String
}

# Change user password
input ChangePasswordInput {
    passwordCurrent: String!
    password: String!
    passwordConfirm: String!
}

type RestoreResponse {
    state: Boolean!
    errors: Any
}

type RestoreConfirmResponse {
    jwt: Jwt
    errors: Any
}

type RegistrationConfirmResponse {
    jwt: Jwt
    errors: Any
}

type RegistrationResponse {
    state: Boolean!
    errors: Any
}

type LoginResponse {
    jwt: Jwt
    errors: Any
}

type ChangePasswordResponse {
    jwt: Jwt
    errors: Any
}

type RefreshTokenResponse {
    result: Jwt
    errors: Any
}

extend type Query {
    me: User! @auth
}

extend type Mutation {
    login(input: LoginInput!): LoginResponse!
    refreshToken(input: RefreshTokenInput!): RefreshTokenResponse!

    restore(input: RestoreInput!): RestoreResponse!
    restoreCheck(input: RestoreCheckInput!): RestoreResponse!
    restoreConfirm(input: RestoreConfirmInput!): RestoreConfirmResponse!

    registration(input: RegistrationInput!): RegistrationResponse!
    registrationConfirm(input: RegistrationConfirmInput!): RegistrationConfirmResponse!

    changePassword(input: ChangePasswordInput!): ChangePasswordResponse! @auth
}
`, BuiltIn: false},
	{Name: "../schema/billing.graphqls", Input: `type Billing {
    requests: Int!
    historyRequests: Int!
}

type BillingAddPacketResponse {
    errors: Any
    billing: BillingPacket
}
`, BuiltIn: false},
	{Name: "../schema/billing_history.graphqls", Input: `type BillingRequest {
    id: ID!
    userId: ID!
    query: String!
    risk: Int!
    category: String!
    network: String!
    createdAt: DateTime!
}

type BillingPacket {
    id: ID!
    userId: ID!
    requests: Int!
    createdAt: DateTime!
}

type BillingHistoryListResponse {
    errors: Any
    total: Int
    edge: [BillingRequest!]!
}

extend type Query {
    billingHistoryList(page: Int!, pageSize: Int!): BillingHistoryListResponse! @auth
}

extend type Mutation {
    billingAddPacket(userId: ID!, requests: Int!): BillingAddPacketResponse! @auth(permissions: ["billing.add_packet"])
}

`, BuiltIn: false},
	{Name: "../schema/billing_key.graphqls", Input: `type BillingKey {
    id: ID!
    userId: ID!
    billingId: ID!
    key: String!
    createdAt: DateTime!
}

type BillingKeyResponse {
    errors: Any
    total: Int
    edge: [BillingKey!]!
}

extend type Query {
    billingKeyList(page: Int!, pageSize: Int!): BillingKeyResponse! @auth
}

extend type Mutation {
    billingKeyCreate: BillingKey! @auth
    billingKeyRemove(id: ID!): Boolean! @auth
}
`, BuiltIn: false},
	{Name: "../schema/blockchain.graphqls", Input: `type Node {
    id: Int64!
    labels: [String!]!
    props: Any
}

type NodeListResponse {
    errors: Any
    total: Int
    edge: [Node!]!
}

type NodeEntityResponse {
    errors: Any
    node: Node
}

type NodeCountResponse {
    errors: Any
    has: Boolean
}
`, BuiltIn: false},
	{Name: "../schema/btc.graphqls", Input: `extend type Query {
    btcExistsAddressByHashCount(address: String!): NodeCountResponse!
    btcExistsTransactionByHashCount(address: String!): NodeCountResponse!

    btcFindContactByAddress(address: String!): NodeEntityResponse!
    btcFindTransactionByHash(address: String!): NodeEntityResponse!
    btcFindAddressByHash(address: String!): NodeEntityResponse!
    btcFindWalletForAddress(address: String!): NodeEntityResponse!
    btcFindRiskScore(address: String!): NodeEntityResponse!
    btcFindBlockByNumber(height: Int!): NodeEntityResponse!
    btcFindBlockByHash(hash: String!): NodeEntityResponse!
    btcFindBlockByTransaction(txid: String!): NodeEntityResponse!
    btcFindTransactionsByAddress(address: String!, page: Int!, pageSize: Int!): NodeListResponse!
    btcFindMentionsForAddress(address: String!, page: Int!, pageSize: Int!): NodeListResponse!
    btcFindIncomingTransactions(txid: String!, page: Int!, pageSize: Int!): NodeListResponse!
    btcFindOutcomingTransactions(txid: String!, page: Int!, pageSize: Int!): NodeListResponse!
    btcFindTransactionsInBlock(height: Int!, page: Int!, pageSize: Int!): NodeListResponse!
    btcFindAllInputAndOutputByTransaction(txid: String!, page: Int!, pageSize: Int!): NodeListResponse!
    btcFindTransactionsInBlockByHash(hash: String!, page: Int!, pageSize: Int!): NodeListResponse!
    btcFindWalletByWid(wid: String!): NodeEntityResponse!
    btcFindWalletAddresses(wid: String!, page: Int!, pageSize: Int!): NodeListResponse!
}
`, BuiltIn: false},
	{Name: "../schema/category.graphqls", Input: `type Category {
    id: ID!
    name: String!
    descriptionRu: String!
    descriptionEn: String!
    risk: Int!
}

type CategoryListResponse {
    errors: Any
    total: Int
    edge: [Category!]!
}

type CategoryCreateResponse {
    errors: Any
    category: Category
}

type CategoryUpdateResponse {
    errors: Any
    category: Category
}

type CategoryRemoveResponse {
    errors: Any
}

input CategoryCreateInput {
    name: String!
    descriptionRu: String!
    descriptionEn: String!
    risk: Int!
}

input CategoryUpdateInput {
    name: String
    descriptionRu: String
    descriptionEn: String
    risk: Int
}

extend type Query {
    categoryList: CategoryListResponse! @auth(permissions: ["category"])
    categoryFindById(id: ID!): Category @auth(permissions: ["category"])
}

extend type Mutation {
    categoryCreate(input: CategoryCreateInput!): CategoryCreateResponse! @auth(permissions: ["category"])
    categoryUpdate(id: ID!, input: CategoryUpdateInput!): CategoryUpdateResponse! @auth(permissions: ["category"])
    categoryRemoveById(id: ID!): CategoryRemoveResponse @auth(permissions: ["category"])
}
`, BuiltIn: false},
	{Name: "../schema/directive.graphqls", Input: `# Authentication required
directive @auth(permissions: [String!]) on FIELD_DEFINITION
# Authentication via refresh token
directive @authRefresh on FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../schema/eth.graphqls", Input: `extend type Query {
    ethFindAddressByHash(address: String!): NodeEntityResponse!
    ethFindTransactionsByAddress(hash: String!, page: Int!, pageSize: Int!): NodeListResponse!
    ethFindTransactionByHash(hash: String!): NodeEntityResponse!
    ethFindIncomingTransactionAddress(hash: String!): NodeEntityResponse!
    ethFindOutcomingTransactionAddress(hash: String!): NodeEntityResponse!
    ethFindBlockByTransaction(hash: String!): NodeEntityResponse!
    ethFindBlockByHeight(height: String!): NodeEntityResponse!
    ethFindTransactionsInBlock(height: String!, page: Int!, pageSize: Int!): NodeListResponse!
    ethFindAllInputAndOutputTransactions(hash: String!, page: Int!, pageSize: Int!): NodeListResponse!
    ethFindBlockByHash(hash: String!): NodeEntityResponse!
    ethFindMentionsByAddress(address: String!, page: Int!, pageSize: Int!): NodeListResponse!
    ethFindContactByAddress(address: String!): NodeEntityResponse!
    ethFindRiskScoreByAddress(address: String!): NodeEntityResponse!
}
`, BuiltIn: false},
	{Name: "../schema/health.graphqls", Input: `type Query {
    health: Boolean!
}

type Subscription {
    health: Boolean!
}

type Mutation {
    health: Boolean!
}`, BuiltIn: false},
	{Name: "../schema/other.graphqls", Input: `type PageInfo {
    startCursor: ID!
    endCursor: ID!
    hasNextPage: Boolean!
}`, BuiltIn: false},
	{Name: "../schema/scalar.graphqls", Input: `scalar Upload
scalar Date
scalar DateTime
scalar JSON
scalar Integer
scalar Int64
scalar Map
scalar Any`, BuiltIn: false},
	{Name: "../schema/search.graphqls", Input: `type Entity {
    date: DateTime!
    address: String!
    chain: String!
    contact: String!
    category: String!
    data: Any!
}

type SearchResponse {
    errors: Any
    total: Int
    edge: [Entity!]!
}

type SearchCountResponse {
    errors: Any
    count: Int
}

extend type Query {
    search(query: String!, page: Int! = 0, limit: Int! = 100): SearchResponse! @auth(permissions: ["subscription"])
    searchCount(query: String!): SearchCountResponse!
}
`, BuiltIn: false},
	{Name: "../schema/user.graphqls", Input: `type User {
    id: ID!
    name: String!
    email: String!
    isActive: Boolean!
    createdAt: String!
    updatedAt: String!
    billing: Billing!
    permissions: [String!]! @auth(permissions: ["user.show_permissions"])
}

type UserListResponse {
    errors: Any
    total: Int
    edge: [User!]!
}

extend type Query {
    user(id: ID!): User!
    userList(page: Int!, pageSize: Int!): UserListResponse! @auth(permissions: ["user.list"])
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_auth_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["permissions"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
		arg0, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["permissions"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_billingAddPacket_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int64
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalNID2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["requests"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requests"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["requests"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_billingKeyRemove_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_categoryCreate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CategoryCreateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCategoryCreateInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryCreateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_categoryRemoveById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_categoryUpdate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.CategoryUpdateInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg1, err = ec.unmarshalNCategoryUpdateInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryUpdateInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_changePassword_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.ChangePasswordInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNChangePasswordInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐChangePasswordInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_login_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.LoginInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNLoginInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐLoginInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_refreshToken_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RefreshTokenInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRefreshTokenInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRefreshTokenInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registrationConfirm_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RegistrationConfirmInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRegistrationConfirmInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationConfirmInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_registration_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RegistrationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRegistrationInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_restoreCheck_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RestoreCheckInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRestoreCheckInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreCheckInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_restoreConfirm_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RestoreConfirmInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRestoreConfirmInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreConfirmInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_restore_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.RestoreInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNRestoreInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_billingHistoryList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_billingKeyList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_btcExistsAddressByHashCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcExistsTransactionByHashCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindAddressByHash_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindAllInputAndOutputByTransaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["txid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txid"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txid"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_btcFindBlockByHash_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindBlockByNumber_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["height"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["height"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindBlockByTransaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["txid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txid"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txid"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindContactByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindIncomingTransactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["txid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txid"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txid"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_btcFindMentionsForAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_btcFindOutcomingTransactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["txid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("txid"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["txid"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_btcFindRiskScore_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindTransactionByHash_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindTransactionsByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_btcFindTransactionsInBlockByHash_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_btcFindTransactionsInBlock_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["height"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["height"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_btcFindWalletAddresses_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["wid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wid"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["wid"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_btcFindWalletByWid_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["wid"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wid"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["wid"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_btcFindWalletForAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_categoryFindById_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindAddressByHash_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindAllInputAndOutputTransactions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_ethFindBlockByHash_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindBlockByHeight_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["height"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["height"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindBlockByTransaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindContactByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindIncomingTransactionAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindMentionsByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_ethFindOutcomingTransactionAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindRiskScoreByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["address"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("address"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["address"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindTransactionByHash_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_ethFindTransactionsByAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hash"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hash"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_ethFindTransactionsInBlock_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["height"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["height"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_searchCount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_search_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_userList_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["pageSize"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pageSize"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["pageSize"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int64
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2int64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Billing_requests(ctx context.Context, field graphql.CollectedField, obj *model.Billing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Billing_requests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Billing_requests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Billing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Billing_historyRequests(ctx context.Context, field graphql.CollectedField, obj *model.Billing) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Billing_historyRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HistoryRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Billing_historyRequests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Billing",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingAddPacketResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.BillingAddPacketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingAddPacketResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingAddPacketResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingAddPacketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingAddPacketResponse_billing(ctx context.Context, field graphql.CollectedField, obj *model.BillingAddPacketResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingAddPacketResponse_billing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Billing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.BillingPacket)
	fc.Result = res
	return ec.marshalOBillingPacket2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingPacket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingAddPacketResponse_billing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingAddPacketResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BillingPacket_id(ctx, field)
			case "userId":
				return ec.fieldContext_BillingPacket_userId(ctx, field)
			case "requests":
				return ec.fieldContext_BillingPacket_requests(ctx, field)
			case "createdAt":
				return ec.fieldContext_BillingPacket_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BillingPacket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingHistoryListResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.BillingHistoryListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingHistoryListResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingHistoryListResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingHistoryListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingHistoryListResponse_total(ctx context.Context, field graphql.CollectedField, obj *model.BillingHistoryListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingHistoryListResponse_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingHistoryListResponse_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingHistoryListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingHistoryListResponse_edge(ctx context.Context, field graphql.CollectedField, obj *model.BillingHistoryListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingHistoryListResponse_edge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.BillingRequest)
	fc.Result = res
	return ec.marshalNBillingRequest2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingRequestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingHistoryListResponse_edge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingHistoryListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BillingRequest_id(ctx, field)
			case "userId":
				return ec.fieldContext_BillingRequest_userId(ctx, field)
			case "query":
				return ec.fieldContext_BillingRequest_query(ctx, field)
			case "risk":
				return ec.fieldContext_BillingRequest_risk(ctx, field)
			case "category":
				return ec.fieldContext_BillingRequest_category(ctx, field)
			case "network":
				return ec.fieldContext_BillingRequest_network(ctx, field)
			case "createdAt":
				return ec.fieldContext_BillingRequest_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BillingRequest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingKey_id(ctx context.Context, field graphql.CollectedField, obj *models.BillingKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingKey_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingKey_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingKey_userId(ctx context.Context, field graphql.CollectedField, obj *models.BillingKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingKey_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingKey_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingKey_billingId(ctx context.Context, field graphql.CollectedField, obj *models.BillingKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingKey_billingId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BillingID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingKey_billingId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingKey_key(ctx context.Context, field graphql.CollectedField, obj *models.BillingKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingKey_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingKey_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingKey_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.BillingKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingKey_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BillingKey().CreatedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingKey_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingKey",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingKeyResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.BillingKeyResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingKeyResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingKeyResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingKeyResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingKeyResponse_total(ctx context.Context, field graphql.CollectedField, obj *model.BillingKeyResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingKeyResponse_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingKeyResponse_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingKeyResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingKeyResponse_edge(ctx context.Context, field graphql.CollectedField, obj *model.BillingKeyResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingKeyResponse_edge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.BillingKey)
	fc.Result = res
	return ec.marshalNBillingKey2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingKeyResponse_edge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingKeyResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BillingKey_id(ctx, field)
			case "userId":
				return ec.fieldContext_BillingKey_userId(ctx, field)
			case "billingId":
				return ec.fieldContext_BillingKey_billingId(ctx, field)
			case "key":
				return ec.fieldContext_BillingKey_key(ctx, field)
			case "createdAt":
				return ec.fieldContext_BillingKey_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BillingKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingPacket_id(ctx context.Context, field graphql.CollectedField, obj *models.BillingPacket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingPacket_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingPacket_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingPacket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingPacket_userId(ctx context.Context, field graphql.CollectedField, obj *models.BillingPacket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingPacket_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingPacket_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingPacket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingPacket_requests(ctx context.Context, field graphql.CollectedField, obj *models.BillingPacket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingPacket_requests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingPacket_requests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingPacket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingPacket_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.BillingPacket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingPacket_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BillingPacket().CreatedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingPacket_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingPacket",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingRequest_id(ctx context.Context, field graphql.CollectedField, obj *models.BillingRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingRequest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingRequest_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingRequest_userId(ctx context.Context, field graphql.CollectedField, obj *models.BillingRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingRequest_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingRequest_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingRequest_query(ctx context.Context, field graphql.CollectedField, obj *models.BillingRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingRequest_query(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Query, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingRequest_query(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingRequest_risk(ctx context.Context, field graphql.CollectedField, obj *models.BillingRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingRequest_risk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Risk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingRequest_risk(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingRequest_category(ctx context.Context, field graphql.CollectedField, obj *models.BillingRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingRequest_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingRequest_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingRequest_network(ctx context.Context, field graphql.CollectedField, obj *models.BillingRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingRequest_network(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Network, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingRequest_network(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingRequest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BillingRequest_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.BillingRequest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BillingRequest_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.BillingRequest().CreatedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BillingRequest_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BillingRequest",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Category_id(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Category_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Category_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Category",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Category_name(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Category_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Category_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Category",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Category_descriptionRu(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Category_descriptionRu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DescriptionRu, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Category_descriptionRu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Category",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Category_descriptionEn(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Category_descriptionEn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DescriptionEn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Category_descriptionEn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Category",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Category_risk(ctx context.Context, field graphql.CollectedField, obj *models.Category) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Category_risk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Risk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Category_risk(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Category",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryCreateResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.CategoryCreateResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CategoryCreateResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CategoryCreateResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryCreateResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryCreateResponse_category(ctx context.Context, field graphql.CollectedField, obj *model.CategoryCreateResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CategoryCreateResponse_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Category)
	fc.Result = res
	return ec.marshalOCategory2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CategoryCreateResponse_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryCreateResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Category_id(ctx, field)
			case "name":
				return ec.fieldContext_Category_name(ctx, field)
			case "descriptionRu":
				return ec.fieldContext_Category_descriptionRu(ctx, field)
			case "descriptionEn":
				return ec.fieldContext_Category_descriptionEn(ctx, field)
			case "risk":
				return ec.fieldContext_Category_risk(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryListResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.CategoryListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CategoryListResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CategoryListResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryListResponse_total(ctx context.Context, field graphql.CollectedField, obj *model.CategoryListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CategoryListResponse_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CategoryListResponse_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryListResponse_edge(ctx context.Context, field graphql.CollectedField, obj *model.CategoryListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CategoryListResponse_edge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.Category)
	fc.Result = res
	return ec.marshalNCategory2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐCategoryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CategoryListResponse_edge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Category_id(ctx, field)
			case "name":
				return ec.fieldContext_Category_name(ctx, field)
			case "descriptionRu":
				return ec.fieldContext_Category_descriptionRu(ctx, field)
			case "descriptionEn":
				return ec.fieldContext_Category_descriptionEn(ctx, field)
			case "risk":
				return ec.fieldContext_Category_risk(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryRemoveResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.CategoryRemoveResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CategoryRemoveResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CategoryRemoveResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryRemoveResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryUpdateResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.CategoryUpdateResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CategoryUpdateResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CategoryUpdateResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryUpdateResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CategoryUpdateResponse_category(ctx context.Context, field graphql.CollectedField, obj *model.CategoryUpdateResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CategoryUpdateResponse_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Category)
	fc.Result = res
	return ec.marshalOCategory2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CategoryUpdateResponse_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CategoryUpdateResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Category_id(ctx, field)
			case "name":
				return ec.fieldContext_Category_name(ctx, field)
			case "descriptionRu":
				return ec.fieldContext_Category_descriptionRu(ctx, field)
			case "descriptionEn":
				return ec.fieldContext_Category_descriptionEn(ctx, field)
			case "risk":
				return ec.fieldContext_Category_risk(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangePasswordResponse_jwt(ctx context.Context, field graphql.CollectedField, obj *model.ChangePasswordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangePasswordResponse_jwt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jwt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Jwt)
	fc.Result = res
	return ec.marshalOJwt2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐJwt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangePasswordResponse_jwt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangePasswordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Jwt_id(ctx, field)
			case "accessToken":
				return ec.fieldContext_Jwt_accessToken(ctx, field)
			case "permissions":
				return ec.fieldContext_Jwt_permissions(ctx, field)
			case "refreshToken":
				return ec.fieldContext_Jwt_refreshToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Jwt", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChangePasswordResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.ChangePasswordResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChangePasswordResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChangePasswordResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChangePasswordResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entity_date(ctx context.Context, field graphql.CollectedField, obj *elastic.Entity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DateTime does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entity_address(ctx context.Context, field graphql.CollectedField, obj *elastic.Entity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entity_chain(ctx context.Context, field graphql.CollectedField, obj *elastic.Entity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_chain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Chain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_chain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entity_contact(ctx context.Context, field graphql.CollectedField, obj *elastic.Entity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_contact(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Contact, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_contact(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entity_category(ctx context.Context, field graphql.CollectedField, obj *elastic.Entity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Entity_data(ctx context.Context, field graphql.CollectedField, obj *elastic.Entity) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Entity_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(any)
	fc.Result = res
	return ec.marshalNAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Entity_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Entity",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Jwt_id(ctx context.Context, field graphql.CollectedField, obj *models.Jwt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Jwt_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Jwt_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Jwt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Jwt_accessToken(ctx context.Context, field graphql.CollectedField, obj *models.Jwt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Jwt_accessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccessToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Jwt_accessToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Jwt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Jwt_permissions(ctx context.Context, field graphql.CollectedField, obj *models.Jwt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Jwt_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Permissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Jwt_permissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Jwt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Jwt_refreshToken(ctx context.Context, field graphql.CollectedField, obj *models.Jwt) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Jwt_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RefreshToken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Jwt_refreshToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Jwt",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginResponse_jwt(ctx context.Context, field graphql.CollectedField, obj *model.LoginResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginResponse_jwt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jwt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Jwt)
	fc.Result = res
	return ec.marshalOJwt2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐJwt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginResponse_jwt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Jwt_id(ctx, field)
			case "accessToken":
				return ec.fieldContext_Jwt_accessToken(ctx, field)
			case "permissions":
				return ec.fieldContext_Jwt_permissions(ctx, field)
			case "refreshToken":
				return ec.fieldContext_Jwt_refreshToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Jwt", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoginResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.LoginResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoginResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoginResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoginResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_health(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Health(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_accessRequest(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_accessRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().AccessRequest(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_accessRequest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_login(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_login(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Login(rctx, fc.Args["input"].(model.LoginInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.LoginResponse)
	fc.Result = res
	return ec.marshalNLoginResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐLoginResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_login(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jwt":
				return ec.fieldContext_LoginResponse_jwt(ctx, field)
			case "errors":
				return ec.fieldContext_LoginResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoginResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_login_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_refreshToken(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_refreshToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RefreshToken(rctx, fc.Args["input"].(model.RefreshTokenInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RefreshTokenResponse)
	fc.Result = res
	return ec.marshalNRefreshTokenResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRefreshTokenResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_refreshToken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "result":
				return ec.fieldContext_RefreshTokenResponse_result(ctx, field)
			case "errors":
				return ec.fieldContext_RefreshTokenResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RefreshTokenResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_refreshToken_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restore(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Restore(rctx, fc.Args["input"].(model.RestoreInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RestoreResponse)
	fc.Result = res
	return ec.marshalNRestoreResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_RestoreResponse_state(ctx, field)
			case "errors":
				return ec.fieldContext_RestoreResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RestoreResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restore_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restoreCheck(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restoreCheck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestoreCheck(rctx, fc.Args["input"].(model.RestoreCheckInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RestoreResponse)
	fc.Result = res
	return ec.marshalNRestoreResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restoreCheck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_RestoreResponse_state(ctx, field)
			case "errors":
				return ec.fieldContext_RestoreResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RestoreResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restoreCheck_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restoreConfirm(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restoreConfirm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestoreConfirm(rctx, fc.Args["input"].(model.RestoreConfirmInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RestoreConfirmResponse)
	fc.Result = res
	return ec.marshalNRestoreConfirmResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreConfirmResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restoreConfirm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jwt":
				return ec.fieldContext_RestoreConfirmResponse_jwt(ctx, field)
			case "errors":
				return ec.fieldContext_RestoreConfirmResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RestoreConfirmResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restoreConfirm_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registration(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Registration(rctx, fc.Args["input"].(model.RegistrationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RegistrationResponse)
	fc.Result = res
	return ec.marshalNRegistrationResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "state":
				return ec.fieldContext_RegistrationResponse_state(ctx, field)
			case "errors":
				return ec.fieldContext_RegistrationResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RegistrationResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registration_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_registrationConfirm(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_registrationConfirm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RegistrationConfirm(rctx, fc.Args["input"].(model.RegistrationConfirmInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RegistrationConfirmResponse)
	fc.Result = res
	return ec.marshalNRegistrationConfirmResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationConfirmResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_registrationConfirm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jwt":
				return ec.fieldContext_RegistrationConfirmResponse_jwt(ctx, field)
			case "errors":
				return ec.fieldContext_RegistrationConfirmResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RegistrationConfirmResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_registrationConfirm_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_changePassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ChangePassword(rctx, fc.Args["input"].(model.ChangePasswordInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ChangePasswordResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.ChangePasswordResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ChangePasswordResponse)
	fc.Result = res
	return ec.marshalNChangePasswordResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐChangePasswordResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_changePassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "jwt":
				return ec.fieldContext_ChangePasswordResponse_jwt(ctx, field)
			case "errors":
				return ec.fieldContext_ChangePasswordResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChangePasswordResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_changePassword_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_billingAddPacket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_billingAddPacket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().BillingAddPacket(rctx, fc.Args["userId"].(int64), fc.Args["requests"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"billing.add_packet"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BillingAddPacketResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.BillingAddPacketResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BillingAddPacketResponse)
	fc.Result = res
	return ec.marshalNBillingAddPacketResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingAddPacketResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_billingAddPacket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_BillingAddPacketResponse_errors(ctx, field)
			case "billing":
				return ec.fieldContext_BillingAddPacketResponse_billing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BillingAddPacketResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_billingAddPacket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_billingKeyCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_billingKeyCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().BillingKeyCreate(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.BillingKey); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/pkg/models.BillingKey`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.BillingKey)
	fc.Result = res
	return ec.marshalNBillingKey2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingKey(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_billingKeyCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BillingKey_id(ctx, field)
			case "userId":
				return ec.fieldContext_BillingKey_userId(ctx, field)
			case "billingId":
				return ec.fieldContext_BillingKey_billingId(ctx, field)
			case "key":
				return ec.fieldContext_BillingKey_key(ctx, field)
			case "createdAt":
				return ec.fieldContext_BillingKey_createdAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BillingKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_billingKeyRemove(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_billingKeyRemove(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().BillingKeyRemove(rctx, fc.Args["id"].(int64))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_billingKeyRemove(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_billingKeyRemove_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_categoryCreate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_categoryCreate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CategoryCreate(rctx, fc.Args["input"].(model.CategoryCreateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"category"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CategoryCreateResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.CategoryCreateResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CategoryCreateResponse)
	fc.Result = res
	return ec.marshalNCategoryCreateResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryCreateResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_categoryCreate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_CategoryCreateResponse_errors(ctx, field)
			case "category":
				return ec.fieldContext_CategoryCreateResponse_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CategoryCreateResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_categoryCreate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_categoryUpdate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_categoryUpdate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CategoryUpdate(rctx, fc.Args["id"].(int64), fc.Args["input"].(model.CategoryUpdateInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"category"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CategoryUpdateResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.CategoryUpdateResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CategoryUpdateResponse)
	fc.Result = res
	return ec.marshalNCategoryUpdateResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryUpdateResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_categoryUpdate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_CategoryUpdateResponse_errors(ctx, field)
			case "category":
				return ec.fieldContext_CategoryUpdateResponse_category(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CategoryUpdateResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_categoryUpdate_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_categoryRemoveById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_categoryRemoveById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().CategoryRemoveByID(rctx, fc.Args["id"].(int64))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"category"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CategoryRemoveResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.CategoryRemoveResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CategoryRemoveResponse)
	fc.Result = res
	return ec.marshalOCategoryRemoveResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryRemoveResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_categoryRemoveById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_CategoryRemoveResponse_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CategoryRemoveResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_categoryRemoveById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Node_id(ctx context.Context, field graphql.CollectedField, obj *neoutils.Node) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Node_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt642int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Node_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int64 does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_labels(ctx context.Context, field graphql.CollectedField, obj *neoutils.Node) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Node_labels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Labels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Node_labels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Node_props(ctx context.Context, field graphql.CollectedField, obj *neoutils.Node) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Node_props(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Node().Props(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Node_props(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Node",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeCountResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.NodeCountResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeCountResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeCountResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeCountResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeCountResponse_has(ctx context.Context, field graphql.CollectedField, obj *model.NodeCountResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeCountResponse_has(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Has, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeCountResponse_has(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeCountResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeEntityResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.NodeEntityResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeEntityResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeEntityResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeEntityResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeEntityResponse_node(ctx context.Context, field graphql.CollectedField, obj *model.NodeEntityResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeEntityResponse_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*neoutils.Node)
	fc.Result = res
	return ec.marshalONode2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋneoutilsᚐNode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeEntityResponse_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeEntityResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "props":
				return ec.fieldContext_Node_props(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeListResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.NodeListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeListResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeListResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeListResponse_total(ctx context.Context, field graphql.CollectedField, obj *model.NodeListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeListResponse_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeListResponse_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NodeListResponse_edge(ctx context.Context, field graphql.CollectedField, obj *model.NodeListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NodeListResponse_edge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*neoutils.Node)
	fc.Result = res
	return ec.marshalNNode2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋneoutilsᚐNodeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NodeListResponse_edge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NodeListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Node_id(ctx, field)
			case "labels":
				return ec.fieldContext_Node_labels(ctx, field)
			case "props":
				return ec.fieldContext_Node_props(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Node", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *model.PageInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_health(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_health(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Health(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_me(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_me(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Me(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.User); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/pkg/models.User`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_me(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "billing":
				return ec.fieldContext_User_billing(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_billingHistoryList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_billingHistoryList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BillingHistoryList(rctx, fc.Args["page"].(int), fc.Args["pageSize"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BillingHistoryListResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.BillingHistoryListResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BillingHistoryListResponse)
	fc.Result = res
	return ec.marshalNBillingHistoryListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingHistoryListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_billingHistoryList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_BillingHistoryListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_BillingHistoryListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_BillingHistoryListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BillingHistoryListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_billingHistoryList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_billingKeyList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_billingKeyList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().BillingKeyList(rctx, fc.Args["page"].(int), fc.Args["pageSize"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, nil)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.BillingKeyResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.BillingKeyResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.BillingKeyResponse)
	fc.Result = res
	return ec.marshalNBillingKeyResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingKeyResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_billingKeyList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_BillingKeyResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_BillingKeyResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_BillingKeyResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BillingKeyResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_billingKeyList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcExistsAddressByHashCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcExistsAddressByHashCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcExistsAddressByHashCount(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeCountResponse)
	fc.Result = res
	return ec.marshalNNodeCountResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeCountResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcExistsAddressByHashCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeCountResponse_errors(ctx, field)
			case "has":
				return ec.fieldContext_NodeCountResponse_has(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeCountResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcExistsAddressByHashCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcExistsTransactionByHashCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcExistsTransactionByHashCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcExistsTransactionByHashCount(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeCountResponse)
	fc.Result = res
	return ec.marshalNNodeCountResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeCountResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcExistsTransactionByHashCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeCountResponse_errors(ctx, field)
			case "has":
				return ec.fieldContext_NodeCountResponse_has(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeCountResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcExistsTransactionByHashCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindContactByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindContactByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindContactByAddress(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindContactByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindContactByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindTransactionByHash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindTransactionByHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindTransactionByHash(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindTransactionByHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindTransactionByHash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindAddressByHash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindAddressByHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindAddressByHash(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindAddressByHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindAddressByHash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindWalletForAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindWalletForAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindWalletForAddress(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindWalletForAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindWalletForAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindRiskScore(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindRiskScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindRiskScore(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindRiskScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindRiskScore_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindBlockByNumber(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindBlockByNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindBlockByNumber(rctx, fc.Args["height"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindBlockByNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindBlockByNumber_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindBlockByHash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindBlockByHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindBlockByHash(rctx, fc.Args["hash"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindBlockByHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindBlockByHash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindBlockByTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindBlockByTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindBlockByTransaction(rctx, fc.Args["txid"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindBlockByTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindBlockByTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindTransactionsByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindTransactionsByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindTransactionsByAddress(rctx, fc.Args["address"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindTransactionsByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindTransactionsByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindMentionsForAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindMentionsForAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindMentionsForAddress(rctx, fc.Args["address"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindMentionsForAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindMentionsForAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindIncomingTransactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindIncomingTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindIncomingTransactions(rctx, fc.Args["txid"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindIncomingTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindIncomingTransactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindOutcomingTransactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindOutcomingTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindOutcomingTransactions(rctx, fc.Args["txid"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindOutcomingTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindOutcomingTransactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindTransactionsInBlock(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindTransactionsInBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindTransactionsInBlock(rctx, fc.Args["height"].(int), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindTransactionsInBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindTransactionsInBlock_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindAllInputAndOutputByTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindAllInputAndOutputByTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindAllInputAndOutputByTransaction(rctx, fc.Args["txid"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindAllInputAndOutputByTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindAllInputAndOutputByTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindTransactionsInBlockByHash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindTransactionsInBlockByHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindTransactionsInBlockByHash(rctx, fc.Args["hash"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindTransactionsInBlockByHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindTransactionsInBlockByHash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindWalletByWid(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindWalletByWid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindWalletByWid(rctx, fc.Args["wid"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindWalletByWid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindWalletByWid_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_btcFindWalletAddresses(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_btcFindWalletAddresses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BtcFindWalletAddresses(rctx, fc.Args["wid"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_btcFindWalletAddresses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_btcFindWalletAddresses_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_categoryList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_categoryList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CategoryList(rctx)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"category"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.CategoryListResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.CategoryListResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CategoryListResponse)
	fc.Result = res
	return ec.marshalNCategoryListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_categoryList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_CategoryListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_CategoryListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_CategoryListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CategoryListResponse", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_categoryFindById(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_categoryFindById(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().CategoryFindByID(rctx, fc.Args["id"].(int64))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"category"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*models.Category); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/pkg/models.Category`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Category)
	fc.Result = res
	return ec.marshalOCategory2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐCategory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_categoryFindById(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Category_id(ctx, field)
			case "name":
				return ec.fieldContext_Category_name(ctx, field)
			case "descriptionRu":
				return ec.fieldContext_Category_descriptionRu(ctx, field)
			case "descriptionEn":
				return ec.fieldContext_Category_descriptionEn(ctx, field)
			case "risk":
				return ec.fieldContext_Category_risk(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Category", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_categoryFindById_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindAddressByHash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindAddressByHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindAddressByHash(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindAddressByHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindAddressByHash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindTransactionsByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindTransactionsByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindTransactionsByAddress(rctx, fc.Args["hash"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindTransactionsByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindTransactionsByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindTransactionByHash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindTransactionByHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindTransactionByHash(rctx, fc.Args["hash"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindTransactionByHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindTransactionByHash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindIncomingTransactionAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindIncomingTransactionAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindIncomingTransactionAddress(rctx, fc.Args["hash"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindIncomingTransactionAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindIncomingTransactionAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindOutcomingTransactionAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindOutcomingTransactionAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindOutcomingTransactionAddress(rctx, fc.Args["hash"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindOutcomingTransactionAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindOutcomingTransactionAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindBlockByTransaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindBlockByTransaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindBlockByTransaction(rctx, fc.Args["hash"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindBlockByTransaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindBlockByTransaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindBlockByHeight(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindBlockByHeight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindBlockByHeight(rctx, fc.Args["height"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindBlockByHeight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindBlockByHeight_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindTransactionsInBlock(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindTransactionsInBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindTransactionsInBlock(rctx, fc.Args["height"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindTransactionsInBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindTransactionsInBlock_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindAllInputAndOutputTransactions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindAllInputAndOutputTransactions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindAllInputAndOutputTransactions(rctx, fc.Args["hash"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindAllInputAndOutputTransactions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindAllInputAndOutputTransactions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindBlockByHash(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindBlockByHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindBlockByHash(rctx, fc.Args["hash"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindBlockByHash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindBlockByHash_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindMentionsByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindMentionsByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindMentionsByAddress(rctx, fc.Args["address"].(string), fc.Args["page"].(int), fc.Args["pageSize"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeListResponse)
	fc.Result = res
	return ec.marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindMentionsByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_NodeListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_NodeListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindMentionsByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindContactByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindContactByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindContactByAddress(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindContactByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindContactByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_ethFindRiskScoreByAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ethFindRiskScoreByAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().EthFindRiskScoreByAddress(rctx, fc.Args["address"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NodeEntityResponse)
	fc.Result = res
	return ec.marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ethFindRiskScoreByAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_NodeEntityResponse_errors(ctx, field)
			case "node":
				return ec.fieldContext_NodeEntityResponse_node(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NodeEntityResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_ethFindRiskScoreByAddress_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_search(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_search(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().Search(rctx, fc.Args["query"].(string), fc.Args["page"].(int), fc.Args["limit"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"subscription"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.SearchResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.SearchResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SearchResponse)
	fc.Result = res
	return ec.marshalNSearchResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_search(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_SearchResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_SearchResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_SearchResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_search_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_searchCount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_searchCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SearchCount(rctx, fc.Args["query"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SearchCountResponse)
	fc.Result = res
	return ec.marshalNSearchCountResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐSearchCountResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_searchCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_SearchCountResponse_errors(ctx, field)
			case "count":
				return ec.fieldContext_SearchCountResponse_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchCountResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_searchCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["id"].(int64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "billing":
				return ec.fieldContext_User_billing(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_userList(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().UserList(rctx, fc.Args["page"].(int), fc.Args["pageSize"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"user.list"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, nil, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.UserListResponse); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *gitlab.com/rubin-dev/api/internal/graph/model.UserListResponse`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.UserListResponse)
	fc.Result = res
	return ec.marshalNUserListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐUserListResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "errors":
				return ec.fieldContext_UserListResponse_errors(ctx, field)
			case "total":
				return ec.fieldContext_UserListResponse_total(ctx, field)
			case "edge":
				return ec.fieldContext_UserListResponse_edge(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserListResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_userList_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshTokenResponse_result(ctx context.Context, field graphql.CollectedField, obj *model.RefreshTokenResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshTokenResponse_result(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Jwt)
	fc.Result = res
	return ec.marshalOJwt2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐJwt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshTokenResponse_result(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshTokenResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Jwt_id(ctx, field)
			case "accessToken":
				return ec.fieldContext_Jwt_accessToken(ctx, field)
			case "permissions":
				return ec.fieldContext_Jwt_permissions(ctx, field)
			case "refreshToken":
				return ec.fieldContext_Jwt_refreshToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Jwt", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RefreshTokenResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.RefreshTokenResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RefreshTokenResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RefreshTokenResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RefreshTokenResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationConfirmResponse_jwt(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationConfirmResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationConfirmResponse_jwt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jwt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Jwt)
	fc.Result = res
	return ec.marshalOJwt2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐJwt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationConfirmResponse_jwt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationConfirmResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Jwt_id(ctx, field)
			case "accessToken":
				return ec.fieldContext_Jwt_accessToken(ctx, field)
			case "permissions":
				return ec.fieldContext_Jwt_permissions(ctx, field)
			case "refreshToken":
				return ec.fieldContext_Jwt_refreshToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Jwt", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationConfirmResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationConfirmResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationConfirmResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationConfirmResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationConfirmResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationResponse_state(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationResponse_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationResponse_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegistrationResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.RegistrationResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegistrationResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegistrationResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegistrationResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestoreConfirmResponse_jwt(ctx context.Context, field graphql.CollectedField, obj *model.RestoreConfirmResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RestoreConfirmResponse_jwt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jwt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Jwt)
	fc.Result = res
	return ec.marshalOJwt2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐJwt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RestoreConfirmResponse_jwt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestoreConfirmResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Jwt_id(ctx, field)
			case "accessToken":
				return ec.fieldContext_Jwt_accessToken(ctx, field)
			case "permissions":
				return ec.fieldContext_Jwt_permissions(ctx, field)
			case "refreshToken":
				return ec.fieldContext_Jwt_refreshToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Jwt", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestoreConfirmResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.RestoreConfirmResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RestoreConfirmResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RestoreConfirmResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestoreConfirmResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestoreResponse_state(ctx context.Context, field graphql.CollectedField, obj *model.RestoreResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RestoreResponse_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.State, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RestoreResponse_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestoreResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestoreResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.RestoreResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RestoreResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RestoreResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestoreResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchCountResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.SearchCountResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchCountResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchCountResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchCountResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchCountResponse_count(ctx context.Context, field graphql.CollectedField, obj *model.SearchCountResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchCountResponse_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchCountResponse_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchCountResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.SearchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_total(ctx context.Context, field graphql.CollectedField, obj *model.SearchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchResponse_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchResponse_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchResponse_edge(ctx context.Context, field graphql.CollectedField, obj *model.SearchResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchResponse_edge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*elastic.Entity)
	fc.Result = res
	return ec.marshalNEntity2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋelasticᚐEntityᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchResponse_edge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "date":
				return ec.fieldContext_Entity_date(ctx, field)
			case "address":
				return ec.fieldContext_Entity_address(ctx, field)
			case "chain":
				return ec.fieldContext_Entity_chain(ctx, field)
			case "contact":
				return ec.fieldContext_Entity_contact(ctx, field)
			case "category":
				return ec.fieldContext_Entity_category(ctx, field)
			case "data":
				return ec.fieldContext_Entity_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Entity", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscription_health(ctx context.Context, field graphql.CollectedField) (ret func(ctx context.Context) graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscription_health(ctx, field)
	if err != nil {
		return nil
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Subscription().Health(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return nil
	}
	return func(ctx context.Context) graphql.Marshaler {
		res, ok := <-resTmp.(<-chan bool)
		if !ok {
			return nil
		}
		return graphql.WriterFunc(func(w io.Writer) {
			w.Write([]byte{'{'})
			graphql.MarshalString(field.Alias).MarshalGQL(w)
			w.Write([]byte{':'})
			ec.marshalNBoolean2bool(ctx, field.Selections, res).MarshalGQL(w)
			w.Write([]byte{'}'})
		})
	}
}

func (ec *executionContext) fieldContext_Subscription_health(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscription",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_id(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNID2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_name(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_email(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_isActive(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_isActive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_isActive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_createdAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().CreatedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_updatedAt(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().UpdatedAt(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_billing(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_billing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Billing(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Billing)
	fc.Result = res
	return ec.marshalNBilling2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBilling(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_billing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "requests":
				return ec.fieldContext_Billing_requests(ctx, field)
			case "historyRequests":
				return ec.fieldContext_Billing_historyRequests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Billing", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_permissions(ctx context.Context, field graphql.CollectedField, obj *models.User) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Permissions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			permissions, err := ec.unmarshalOString2ᚕstringᚄ(ctx, []interface{}{"user.show_permissions"})
			if err != nil {
				return nil, err
			}
			if ec.directives.Auth == nil {
				return nil, errors.New("directive auth is not implemented")
			}
			return ec.directives.Auth(ctx, obj, directive0, permissions)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_permissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserListResponse_errors(ctx context.Context, field graphql.CollectedField, obj *model.UserListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserListResponse_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserListResponse_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserListResponse_total(ctx context.Context, field graphql.CollectedField, obj *model.UserListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserListResponse_total(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserListResponse_total(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserListResponse_edge(ctx context.Context, field graphql.CollectedField, obj *model.UserListResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserListResponse_edge(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edge, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*models.User)
	fc.Result = res
	return ec.marshalNUser2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserListResponse_edge(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserListResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_User_id(ctx, field)
			case "name":
				return ec.fieldContext_User_name(ctx, field)
			case "email":
				return ec.fieldContext_User_email(ctx, field)
			case "isActive":
				return ec.fieldContext_User_isActive(ctx, field)
			case "createdAt":
				return ec.fieldContext_User_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_User_updatedAt(ctx, field)
			case "billing":
				return ec.fieldContext_User_billing(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCategoryCreateInput(ctx context.Context, obj interface{}) (model.CategoryCreateInput, error) {
	var it model.CategoryCreateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionRu":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionRu"))
			it.DescriptionRu, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEn"))
			it.DescriptionEn, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "risk":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("risk"))
			it.Risk, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCategoryUpdateInput(ctx context.Context, obj interface{}) (model.CategoryUpdateInput, error) {
	var it model.CategoryUpdateInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionRu":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionRu"))
			it.DescriptionRu, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "descriptionEn":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("descriptionEn"))
			it.DescriptionEn, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "risk":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("risk"))
			it.Risk, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputChangePasswordInput(ctx context.Context, obj interface{}) (model.ChangePasswordInput, error) {
	var it model.ChangePasswordInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "passwordCurrent":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordCurrent"))
			it.PasswordCurrent, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordConfirm":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordConfirm"))
			it.PasswordConfirm, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoginInput(ctx context.Context, obj interface{}) (model.LoginInput, error) {
	var it model.LoginInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			it.Email, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRefreshTokenInput(ctx context.Context, obj interface{}) (model.RefreshTokenInput, error) {
	var it model.RefreshTokenInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "token":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegistrationConfirmInput(ctx context.Context, obj interface{}) (model.RegistrationConfirmInput, error) {
	var it model.RegistrationConfirmInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "token":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRegistrationInput(ctx context.Context, obj interface{}) (model.RegistrationInput, error) {
	var it model.RegistrationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			it.Email, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			it.Password, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordConfirm":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordConfirm"))
			it.PasswordConfirm, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRestoreCheckInput(ctx context.Context, obj interface{}) (model.RestoreCheckInput, error) {
	var it model.RestoreCheckInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "token":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRestoreConfirmInput(ctx context.Context, obj interface{}) (model.RestoreConfirmInput, error) {
	var it model.RestoreConfirmInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "token":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			it.Token, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "passwordConfirm":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("passwordConfirm"))
			it.PasswordConfirm, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRestoreInput(ctx context.Context, obj interface{}) (model.RestoreInput, error) {
	var it model.RestoreInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	for k, v := range asMap {
		switch k {
		case "email":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			it.Email, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var billingImplementors = []string{"Billing"}

func (ec *executionContext) _Billing(ctx context.Context, sel ast.SelectionSet, obj *model.Billing) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, billingImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Billing")
		case "requests":

			out.Values[i] = ec._Billing_requests(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "historyRequests":

			out.Values[i] = ec._Billing_historyRequests(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var billingAddPacketResponseImplementors = []string{"BillingAddPacketResponse"}

func (ec *executionContext) _BillingAddPacketResponse(ctx context.Context, sel ast.SelectionSet, obj *model.BillingAddPacketResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, billingAddPacketResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BillingAddPacketResponse")
		case "errors":

			out.Values[i] = ec._BillingAddPacketResponse_errors(ctx, field, obj)

		case "billing":

			out.Values[i] = ec._BillingAddPacketResponse_billing(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var billingHistoryListResponseImplementors = []string{"BillingHistoryListResponse"}

func (ec *executionContext) _BillingHistoryListResponse(ctx context.Context, sel ast.SelectionSet, obj *model.BillingHistoryListResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, billingHistoryListResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BillingHistoryListResponse")
		case "errors":

			out.Values[i] = ec._BillingHistoryListResponse_errors(ctx, field, obj)

		case "total":

			out.Values[i] = ec._BillingHistoryListResponse_total(ctx, field, obj)

		case "edge":

			out.Values[i] = ec._BillingHistoryListResponse_edge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var billingKeyImplementors = []string{"BillingKey"}

func (ec *executionContext) _BillingKey(ctx context.Context, sel ast.SelectionSet, obj *models.BillingKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, billingKeyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BillingKey")
		case "id":

			out.Values[i] = ec._BillingKey_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "userId":

			out.Values[i] = ec._BillingKey_userId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "billingId":

			out.Values[i] = ec._BillingKey_billingId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "key":

			out.Values[i] = ec._BillingKey_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BillingKey_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var billingKeyResponseImplementors = []string{"BillingKeyResponse"}

func (ec *executionContext) _BillingKeyResponse(ctx context.Context, sel ast.SelectionSet, obj *model.BillingKeyResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, billingKeyResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BillingKeyResponse")
		case "errors":

			out.Values[i] = ec._BillingKeyResponse_errors(ctx, field, obj)

		case "total":

			out.Values[i] = ec._BillingKeyResponse_total(ctx, field, obj)

		case "edge":

			out.Values[i] = ec._BillingKeyResponse_edge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var billingPacketImplementors = []string{"BillingPacket"}

func (ec *executionContext) _BillingPacket(ctx context.Context, sel ast.SelectionSet, obj *models.BillingPacket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, billingPacketImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BillingPacket")
		case "id":

			out.Values[i] = ec._BillingPacket_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "userId":

			out.Values[i] = ec._BillingPacket_userId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "requests":

			out.Values[i] = ec._BillingPacket_requests(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BillingPacket_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var billingRequestImplementors = []string{"BillingRequest"}

func (ec *executionContext) _BillingRequest(ctx context.Context, sel ast.SelectionSet, obj *models.BillingRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, billingRequestImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BillingRequest")
		case "id":

			out.Values[i] = ec._BillingRequest_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "userId":

			out.Values[i] = ec._BillingRequest_userId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "query":

			out.Values[i] = ec._BillingRequest_query(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "risk":

			out.Values[i] = ec._BillingRequest_risk(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "category":

			out.Values[i] = ec._BillingRequest_category(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "network":

			out.Values[i] = ec._BillingRequest_network(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BillingRequest_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var categoryImplementors = []string{"Category"}

func (ec *executionContext) _Category(ctx context.Context, sel ast.SelectionSet, obj *models.Category) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Category")
		case "id":

			out.Values[i] = ec._Category_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Category_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "descriptionRu":

			out.Values[i] = ec._Category_descriptionRu(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "descriptionEn":

			out.Values[i] = ec._Category_descriptionEn(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "risk":

			out.Values[i] = ec._Category_risk(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var categoryCreateResponseImplementors = []string{"CategoryCreateResponse"}

func (ec *executionContext) _CategoryCreateResponse(ctx context.Context, sel ast.SelectionSet, obj *model.CategoryCreateResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryCreateResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CategoryCreateResponse")
		case "errors":

			out.Values[i] = ec._CategoryCreateResponse_errors(ctx, field, obj)

		case "category":

			out.Values[i] = ec._CategoryCreateResponse_category(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var categoryListResponseImplementors = []string{"CategoryListResponse"}

func (ec *executionContext) _CategoryListResponse(ctx context.Context, sel ast.SelectionSet, obj *model.CategoryListResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryListResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CategoryListResponse")
		case "errors":

			out.Values[i] = ec._CategoryListResponse_errors(ctx, field, obj)

		case "total":

			out.Values[i] = ec._CategoryListResponse_total(ctx, field, obj)

		case "edge":

			out.Values[i] = ec._CategoryListResponse_edge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var categoryRemoveResponseImplementors = []string{"CategoryRemoveResponse"}

func (ec *executionContext) _CategoryRemoveResponse(ctx context.Context, sel ast.SelectionSet, obj *model.CategoryRemoveResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryRemoveResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CategoryRemoveResponse")
		case "errors":

			out.Values[i] = ec._CategoryRemoveResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var categoryUpdateResponseImplementors = []string{"CategoryUpdateResponse"}

func (ec *executionContext) _CategoryUpdateResponse(ctx context.Context, sel ast.SelectionSet, obj *model.CategoryUpdateResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, categoryUpdateResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CategoryUpdateResponse")
		case "errors":

			out.Values[i] = ec._CategoryUpdateResponse_errors(ctx, field, obj)

		case "category":

			out.Values[i] = ec._CategoryUpdateResponse_category(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var changePasswordResponseImplementors = []string{"ChangePasswordResponse"}

func (ec *executionContext) _ChangePasswordResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ChangePasswordResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, changePasswordResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChangePasswordResponse")
		case "jwt":

			out.Values[i] = ec._ChangePasswordResponse_jwt(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._ChangePasswordResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var entityImplementors = []string{"Entity"}

func (ec *executionContext) _Entity(ctx context.Context, sel ast.SelectionSet, obj *elastic.Entity) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, entityImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Entity")
		case "date":

			out.Values[i] = ec._Entity_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "address":

			out.Values[i] = ec._Entity_address(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "chain":

			out.Values[i] = ec._Entity_chain(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "contact":

			out.Values[i] = ec._Entity_contact(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "category":

			out.Values[i] = ec._Entity_category(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":

			out.Values[i] = ec._Entity_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var jwtImplementors = []string{"Jwt"}

func (ec *executionContext) _Jwt(ctx context.Context, sel ast.SelectionSet, obj *models.Jwt) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jwtImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Jwt")
		case "id":

			out.Values[i] = ec._Jwt_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "accessToken":

			out.Values[i] = ec._Jwt_accessToken(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "permissions":

			out.Values[i] = ec._Jwt_permissions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "refreshToken":

			out.Values[i] = ec._Jwt_refreshToken(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var loginResponseImplementors = []string{"LoginResponse"}

func (ec *executionContext) _LoginResponse(ctx context.Context, sel ast.SelectionSet, obj *model.LoginResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loginResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoginResponse")
		case "jwt":

			out.Values[i] = ec._LoginResponse_jwt(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._LoginResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "health":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_health(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "accessRequest":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_accessRequest(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "login":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_login(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "refreshToken":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_refreshToken(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "restore":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restore(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "restoreCheck":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restoreCheck(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "restoreConfirm":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restoreConfirm(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "registration":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registration(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "registrationConfirm":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_registrationConfirm(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "changePassword":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_changePassword(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "billingAddPacket":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_billingAddPacket(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "billingKeyCreate":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_billingKeyCreate(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "billingKeyRemove":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_billingKeyRemove(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "categoryCreate":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_categoryCreate(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "categoryUpdate":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_categoryUpdate(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "categoryRemoveById":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_categoryRemoveById(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var nodeImplementors = []string{"Node"}

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj *neoutils.Node) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Node")
		case "id":

			out.Values[i] = ec._Node_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "labels":

			out.Values[i] = ec._Node_labels(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "props":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Node_props(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var nodeCountResponseImplementors = []string{"NodeCountResponse"}

func (ec *executionContext) _NodeCountResponse(ctx context.Context, sel ast.SelectionSet, obj *model.NodeCountResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeCountResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeCountResponse")
		case "errors":

			out.Values[i] = ec._NodeCountResponse_errors(ctx, field, obj)

		case "has":

			out.Values[i] = ec._NodeCountResponse_has(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var nodeEntityResponseImplementors = []string{"NodeEntityResponse"}

func (ec *executionContext) _NodeEntityResponse(ctx context.Context, sel ast.SelectionSet, obj *model.NodeEntityResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeEntityResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeEntityResponse")
		case "errors":

			out.Values[i] = ec._NodeEntityResponse_errors(ctx, field, obj)

		case "node":

			out.Values[i] = ec._NodeEntityResponse_node(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var nodeListResponseImplementors = []string{"NodeListResponse"}

func (ec *executionContext) _NodeListResponse(ctx context.Context, sel ast.SelectionSet, obj *model.NodeListResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nodeListResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeListResponse")
		case "errors":

			out.Values[i] = ec._NodeListResponse_errors(ctx, field, obj)

		case "total":

			out.Values[i] = ec._NodeListResponse_total(ctx, field, obj)

		case "edge":

			out.Values[i] = ec._NodeListResponse_edge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *model.PageInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "startCursor":

			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "endCursor":

			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hasNextPage":

			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "health":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_health(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "me":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_me(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "billingHistoryList":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_billingHistoryList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "billingKeyList":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_billingKeyList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcExistsAddressByHashCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcExistsAddressByHashCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcExistsTransactionByHashCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcExistsTransactionByHashCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindContactByAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindContactByAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindTransactionByHash":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindTransactionByHash(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindAddressByHash":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindAddressByHash(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindWalletForAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindWalletForAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindRiskScore":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindRiskScore(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindBlockByNumber":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindBlockByNumber(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindBlockByHash":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindBlockByHash(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindBlockByTransaction":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindBlockByTransaction(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindTransactionsByAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindTransactionsByAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindMentionsForAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindMentionsForAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindIncomingTransactions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindIncomingTransactions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindOutcomingTransactions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindOutcomingTransactions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindTransactionsInBlock":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindTransactionsInBlock(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindAllInputAndOutputByTransaction":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindAllInputAndOutputByTransaction(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindTransactionsInBlockByHash":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindTransactionsInBlockByHash(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindWalletByWid":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindWalletByWid(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "btcFindWalletAddresses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_btcFindWalletAddresses(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "categoryList":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_categoryList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "categoryFindById":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_categoryFindById(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindAddressByHash":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindAddressByHash(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindTransactionsByAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindTransactionsByAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindTransactionByHash":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindTransactionByHash(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindIncomingTransactionAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindIncomingTransactionAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindOutcomingTransactionAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindOutcomingTransactionAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindBlockByTransaction":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindBlockByTransaction(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindBlockByHeight":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindBlockByHeight(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindTransactionsInBlock":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindTransactionsInBlock(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindAllInputAndOutputTransactions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindAllInputAndOutputTransactions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindBlockByHash":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindBlockByHash(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindMentionsByAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindMentionsByAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindContactByAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindContactByAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "ethFindRiskScoreByAddress":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ethFindRiskScoreByAddress(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "search":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_search(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "searchCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_searchCount(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userList":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userList(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var refreshTokenResponseImplementors = []string{"RefreshTokenResponse"}

func (ec *executionContext) _RefreshTokenResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RefreshTokenResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, refreshTokenResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RefreshTokenResponse")
		case "result":

			out.Values[i] = ec._RefreshTokenResponse_result(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._RefreshTokenResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var registrationConfirmResponseImplementors = []string{"RegistrationConfirmResponse"}

func (ec *executionContext) _RegistrationConfirmResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RegistrationConfirmResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registrationConfirmResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegistrationConfirmResponse")
		case "jwt":

			out.Values[i] = ec._RegistrationConfirmResponse_jwt(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._RegistrationConfirmResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var registrationResponseImplementors = []string{"RegistrationResponse"}

func (ec *executionContext) _RegistrationResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RegistrationResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, registrationResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegistrationResponse")
		case "state":

			out.Values[i] = ec._RegistrationResponse_state(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._RegistrationResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var restoreConfirmResponseImplementors = []string{"RestoreConfirmResponse"}

func (ec *executionContext) _RestoreConfirmResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RestoreConfirmResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, restoreConfirmResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestoreConfirmResponse")
		case "jwt":

			out.Values[i] = ec._RestoreConfirmResponse_jwt(ctx, field, obj)

		case "errors":

			out.Values[i] = ec._RestoreConfirmResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var restoreResponseImplementors = []string{"RestoreResponse"}

func (ec *executionContext) _RestoreResponse(ctx context.Context, sel ast.SelectionSet, obj *model.RestoreResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, restoreResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestoreResponse")
		case "state":

			out.Values[i] = ec._RestoreResponse_state(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._RestoreResponse_errors(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var searchCountResponseImplementors = []string{"SearchCountResponse"}

func (ec *executionContext) _SearchCountResponse(ctx context.Context, sel ast.SelectionSet, obj *model.SearchCountResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchCountResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchCountResponse")
		case "errors":

			out.Values[i] = ec._SearchCountResponse_errors(ctx, field, obj)

		case "count":

			out.Values[i] = ec._SearchCountResponse_count(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var searchResponseImplementors = []string{"SearchResponse"}

func (ec *executionContext) _SearchResponse(ctx context.Context, sel ast.SelectionSet, obj *model.SearchResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchResponse")
		case "errors":

			out.Values[i] = ec._SearchResponse_errors(ctx, field, obj)

		case "total":

			out.Values[i] = ec._SearchResponse_total(ctx, field, obj)

		case "edge":

			out.Values[i] = ec._SearchResponse_edge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriptionImplementors = []string{"Subscription"}

func (ec *executionContext) _Subscription(ctx context.Context, sel ast.SelectionSet) func(ctx context.Context) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriptionImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Subscription",
	})
	if len(fields) != 1 {
		ec.Errorf(ctx, "must subscribe to exactly one stream")
		return nil
	}

	switch fields[0].Name {
	case "health":
		return ec._Subscription_health(ctx, fields[0])
	default:
		panic("unknown field " + strconv.Quote(fields[0].Name))
	}
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *models.User) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "id":

			out.Values[i] = ec._User_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._User_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "email":

			out.Values[i] = ec._User_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isActive":

			out.Values[i] = ec._User_isActive(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "updatedAt":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_updatedAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "billing":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_billing(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "permissions":

			out.Values[i] = ec._User_permissions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userListResponseImplementors = []string{"UserListResponse"}

func (ec *executionContext) _UserListResponse(ctx context.Context, sel ast.SelectionSet, obj *model.UserListResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userListResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserListResponse")
		case "errors":

			out.Values[i] = ec._UserListResponse_errors(ctx, field, obj)

		case "total":

			out.Values[i] = ec._UserListResponse_total(ctx, field, obj)

		case "edge":

			out.Values[i] = ec._UserListResponse_edge(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAny2interface(ctx context.Context, v interface{}) (any, error) {
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAny2interface(ctx context.Context, sel ast.SelectionSet, v any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBilling2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBilling(ctx context.Context, sel ast.SelectionSet, v model.Billing) graphql.Marshaler {
	return ec._Billing(ctx, sel, &v)
}

func (ec *executionContext) marshalNBilling2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBilling(ctx context.Context, sel ast.SelectionSet, v *model.Billing) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Billing(ctx, sel, v)
}

func (ec *executionContext) marshalNBillingAddPacketResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingAddPacketResponse(ctx context.Context, sel ast.SelectionSet, v model.BillingAddPacketResponse) graphql.Marshaler {
	return ec._BillingAddPacketResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNBillingAddPacketResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingAddPacketResponse(ctx context.Context, sel ast.SelectionSet, v *model.BillingAddPacketResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BillingAddPacketResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNBillingHistoryListResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingHistoryListResponse(ctx context.Context, sel ast.SelectionSet, v model.BillingHistoryListResponse) graphql.Marshaler {
	return ec._BillingHistoryListResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNBillingHistoryListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingHistoryListResponse(ctx context.Context, sel ast.SelectionSet, v *model.BillingHistoryListResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BillingHistoryListResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNBillingKey2gitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingKey(ctx context.Context, sel ast.SelectionSet, v models.BillingKey) graphql.Marshaler {
	return ec._BillingKey(ctx, sel, &v)
}

func (ec *executionContext) marshalNBillingKey2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingKeyᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.BillingKey) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBillingKey2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingKey(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBillingKey2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingKey(ctx context.Context, sel ast.SelectionSet, v *models.BillingKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BillingKey(ctx, sel, v)
}

func (ec *executionContext) marshalNBillingKeyResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingKeyResponse(ctx context.Context, sel ast.SelectionSet, v model.BillingKeyResponse) graphql.Marshaler {
	return ec._BillingKeyResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNBillingKeyResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐBillingKeyResponse(ctx context.Context, sel ast.SelectionSet, v *model.BillingKeyResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BillingKeyResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNBillingRequest2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingRequestᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.BillingRequest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBillingRequest2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingRequest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBillingRequest2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingRequest(ctx context.Context, sel ast.SelectionSet, v *models.BillingRequest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BillingRequest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCategory2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐCategoryᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.Category) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCategory2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐCategory(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCategory2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐCategory(ctx context.Context, sel ast.SelectionSet, v *models.Category) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Category(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCategoryCreateInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryCreateInput(ctx context.Context, v interface{}) (model.CategoryCreateInput, error) {
	res, err := ec.unmarshalInputCategoryCreateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCategoryCreateResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryCreateResponse(ctx context.Context, sel ast.SelectionSet, v model.CategoryCreateResponse) graphql.Marshaler {
	return ec._CategoryCreateResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCategoryCreateResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryCreateResponse(ctx context.Context, sel ast.SelectionSet, v *model.CategoryCreateResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CategoryCreateResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNCategoryListResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryListResponse(ctx context.Context, sel ast.SelectionSet, v model.CategoryListResponse) graphql.Marshaler {
	return ec._CategoryListResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCategoryListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryListResponse(ctx context.Context, sel ast.SelectionSet, v *model.CategoryListResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CategoryListResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCategoryUpdateInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryUpdateInput(ctx context.Context, v interface{}) (model.CategoryUpdateInput, error) {
	res, err := ec.unmarshalInputCategoryUpdateInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCategoryUpdateResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryUpdateResponse(ctx context.Context, sel ast.SelectionSet, v model.CategoryUpdateResponse) graphql.Marshaler {
	return ec._CategoryUpdateResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNCategoryUpdateResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryUpdateResponse(ctx context.Context, sel ast.SelectionSet, v *model.CategoryUpdateResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CategoryUpdateResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNChangePasswordInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐChangePasswordInput(ctx context.Context, v interface{}) (model.ChangePasswordInput, error) {
	res, err := ec.unmarshalInputChangePasswordInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChangePasswordResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐChangePasswordResponse(ctx context.Context, sel ast.SelectionSet, v model.ChangePasswordResponse) graphql.Marshaler {
	return ec._ChangePasswordResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNChangePasswordResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐChangePasswordResponse(ctx context.Context, sel ast.SelectionSet, v *model.ChangePasswordResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ChangePasswordResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNEntity2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋelasticᚐEntityᚄ(ctx context.Context, sel ast.SelectionSet, v []*elastic.Entity) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEntity2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋelasticᚐEntity(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEntity2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋelasticᚐEntity(ctx context.Context, sel ast.SelectionSet, v *elastic.Entity) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Entity(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt642int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt642int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNLoginInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐLoginInput(ctx context.Context, v interface{}) (model.LoginInput, error) {
	res, err := ec.unmarshalInputLoginInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLoginResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐLoginResponse(ctx context.Context, sel ast.SelectionSet, v model.LoginResponse) graphql.Marshaler {
	return ec._LoginResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNLoginResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐLoginResponse(ctx context.Context, sel ast.SelectionSet, v *model.LoginResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LoginResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNNode2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋneoutilsᚐNodeᚄ(ctx context.Context, sel ast.SelectionSet, v []*neoutils.Node) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNode2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋneoutilsᚐNode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNode2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋneoutilsᚐNode(ctx context.Context, sel ast.SelectionSet, v *neoutils.Node) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalNNodeCountResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeCountResponse(ctx context.Context, sel ast.SelectionSet, v model.NodeCountResponse) graphql.Marshaler {
	return ec._NodeCountResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNNodeCountResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeCountResponse(ctx context.Context, sel ast.SelectionSet, v *model.NodeCountResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NodeCountResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNNodeEntityResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx context.Context, sel ast.SelectionSet, v model.NodeEntityResponse) graphql.Marshaler {
	return ec._NodeEntityResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNNodeEntityResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeEntityResponse(ctx context.Context, sel ast.SelectionSet, v *model.NodeEntityResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NodeEntityResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNNodeListResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx context.Context, sel ast.SelectionSet, v model.NodeListResponse) graphql.Marshaler {
	return ec._NodeListResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNNodeListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐNodeListResponse(ctx context.Context, sel ast.SelectionSet, v *model.NodeListResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NodeListResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRefreshTokenInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRefreshTokenInput(ctx context.Context, v interface{}) (model.RefreshTokenInput, error) {
	res, err := ec.unmarshalInputRefreshTokenInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRefreshTokenResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRefreshTokenResponse(ctx context.Context, sel ast.SelectionSet, v model.RefreshTokenResponse) graphql.Marshaler {
	return ec._RefreshTokenResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRefreshTokenResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRefreshTokenResponse(ctx context.Context, sel ast.SelectionSet, v *model.RefreshTokenResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RefreshTokenResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRegistrationConfirmInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationConfirmInput(ctx context.Context, v interface{}) (model.RegistrationConfirmInput, error) {
	res, err := ec.unmarshalInputRegistrationConfirmInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRegistrationConfirmResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationConfirmResponse(ctx context.Context, sel ast.SelectionSet, v model.RegistrationConfirmResponse) graphql.Marshaler {
	return ec._RegistrationConfirmResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegistrationConfirmResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationConfirmResponse(ctx context.Context, sel ast.SelectionSet, v *model.RegistrationConfirmResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RegistrationConfirmResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRegistrationInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationInput(ctx context.Context, v interface{}) (model.RegistrationInput, error) {
	res, err := ec.unmarshalInputRegistrationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRegistrationResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v model.RegistrationResponse) graphql.Marshaler {
	return ec._RegistrationResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRegistrationResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRegistrationResponse(ctx context.Context, sel ast.SelectionSet, v *model.RegistrationResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RegistrationResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRestoreCheckInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreCheckInput(ctx context.Context, v interface{}) (model.RestoreCheckInput, error) {
	res, err := ec.unmarshalInputRestoreCheckInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRestoreConfirmInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreConfirmInput(ctx context.Context, v interface{}) (model.RestoreConfirmInput, error) {
	res, err := ec.unmarshalInputRestoreConfirmInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRestoreConfirmResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreConfirmResponse(ctx context.Context, sel ast.SelectionSet, v model.RestoreConfirmResponse) graphql.Marshaler {
	return ec._RestoreConfirmResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRestoreConfirmResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreConfirmResponse(ctx context.Context, sel ast.SelectionSet, v *model.RestoreConfirmResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RestoreConfirmResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRestoreInput2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreInput(ctx context.Context, v interface{}) (model.RestoreInput, error) {
	res, err := ec.unmarshalInputRestoreInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRestoreResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreResponse(ctx context.Context, sel ast.SelectionSet, v model.RestoreResponse) graphql.Marshaler {
	return ec._RestoreResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNRestoreResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐRestoreResponse(ctx context.Context, sel ast.SelectionSet, v *model.RestoreResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RestoreResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSearchCountResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐSearchCountResponse(ctx context.Context, sel ast.SelectionSet, v model.SearchCountResponse) graphql.Marshaler {
	return ec._SearchCountResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchCountResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐSearchCountResponse(ctx context.Context, sel ast.SelectionSet, v *model.SearchCountResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchCountResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNSearchResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResponse(ctx context.Context, sel ast.SelectionSet, v model.SearchResponse) graphql.Marshaler {
	return ec._SearchResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐSearchResponse(ctx context.Context, sel ast.SelectionSet, v *model.SearchResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2gitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v models.User) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚕᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐUserᚄ(ctx context.Context, sel ast.SelectionSet, v []*models.User) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUser2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUser2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐUser(ctx context.Context, sel ast.SelectionSet, v *models.User) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserListResponse2gitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐUserListResponse(ctx context.Context, sel ast.SelectionSet, v model.UserListResponse) graphql.Marshaler {
	return ec._UserListResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNUserListResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐUserListResponse(ctx context.Context, sel ast.SelectionSet, v *model.UserListResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UserListResponse(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	return res
}

func (ec *executionContext) marshalOBillingPacket2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐBillingPacket(ctx context.Context, sel ast.SelectionSet, v *models.BillingPacket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BillingPacket(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCategory2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐCategory(ctx context.Context, sel ast.SelectionSet, v *models.Category) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Category(ctx, sel, v)
}

func (ec *executionContext) marshalOCategoryRemoveResponse2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋinternalᚋgraphᚋmodelᚐCategoryRemoveResponse(ctx context.Context, sel ast.SelectionSet, v *model.CategoryRemoveResponse) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CategoryRemoveResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOJwt2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋmodelsᚐJwt(ctx context.Context, sel ast.SelectionSet, v *models.Jwt) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Jwt(ctx, sel, v)
}

func (ec *executionContext) marshalONode2ᚖgitlabᚗcomᚋrubinᚑdevᚋapiᚋpkgᚋneoutilsᚐNode(ctx context.Context, sel ast.SelectionSet, v *neoutils.Node) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
